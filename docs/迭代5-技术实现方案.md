# ETS 编译器迭代5技术实现方案说明书

## 文档版本历史

| 版本 | 日期 | 修改内容 | 修改人 |
|-----|------|---------|--------|
| v1.0 | 2026-01-31 | 基于原始编译器实现方案创建 | Claude AI Assistant |

---

## 一、原始编译器架构分析（迭代5特性）

### 1.1 核心设计原则

基于对 `src/main/resources/developtools_ace_ets2bundle` 的深入分析，针对迭代5需求的功能特性，原始编译器采用以下处理策略：

#### 原则1：ETS 特有装饰器和资源引用需要特殊转换

**关键发现：** 迭代5的核心需求涉及 ETS 特有的语法，需要专门的转换逻辑：

| 特性 | 处理方式 | 实现文件 |
|-----|---------|---------|
| `@Builder` 装饰器 | 添加 `__builder__` 参数，方法体转换为 create/pop | process_component_build.ts |
| `@Entry` 装饰器 | 验证与@Component一起使用，自动添加导出 | process_ui_syntax.ts |
| `$r()` 资源引用 | 转换为 `__getResourceId__()` 调用 | process_ui_syntax.ts |
| `$rawfile()` 资源引用 | 转换为 `__getRawFileId__()` 调用 | process_ui_syntax.ts |

#### 原则2：状态属性初始化需要生成包装类

**关键发现：** `@State`/`@Prop`/`@Link` 装饰器的属性需要：
1. 生成带有 `__` 后缀的私有属性
2. 生成 getter/setter
3. 在构造函数中初始化

#### 原则3：标准 JavaScript 语法完全保留

break/continue、for 循环、async 方法、泛型、JSDoc 等标准语法应保留原样。

### 1.2 语法分类处理策略（迭代5）

#### A类：ETS 特有语法（需要转换）

| 语法类型 | 处理方式 | 实现文件 |
|---------|---------|---------|
| `@Builder` 方法 | 添加 `__builder__` 参数，方法体转换 | process_component_build.ts |
| `@Entry` 装饰器 | 验证并确保导出 | process_ui_syntax.ts |
| `$r()` 资源引用 | 转换为 `__getResourceId__()` | process_ui_syntax.ts |
| `$rawfile()` 资源引用 | 转换为 `__getRawFileId__()` | process_ui_syntax.ts |
| `@State/@Prop/@Link` 属性 | 生成包装属性和初始化逻辑 | process_component_class.ts |

#### B类：标准 JavaScript/TypeScript 语法（保留原样）

| 语法类型 | 处理方式 | 说明 |
|---------|---------|-----|
| **break/continue** | 保留原样 | 标准跳转语句 |
| **for 循环** | 保留原样 | `for(init; cond; incr)` |
| **async 方法** | 保留 async 关键字 | `async method()` |
| **泛型语法** | 移除泛型参数 | `function<T>(arg)` → `function(arg)` |
| **JSDoc 注释** | 保留原样 | TypeScript 自动保留 |

#### C类：代码质量问题（需要修复）

| 问题 | 处理方式 | 优先级 |
|-----|---------|-------|
| async 箭头函数丢失 async | 修复 ArrowFunctionConverter | P0 |
| 代码缩进不正确 | 修复 CodeGenerator | P0 |
| 输出目录结构扁平化 | 修改文件输出逻辑 | P1 |

### 1.3 关键代码模式（原始编译器）

#### 模式1：@Builder 方法参数转换

**来源：** `compiler/src/process_component_build.ts`

```typescript
// parseGlobalBuilderParams 函数解析 @Builder 方法参数
export function parseGlobalBuilderParams(params: ts.NodeArray<ts.ParameterDeclaration>,
  hasBuilderParam: boolean): BuilderParamsResult {
  const result: BuilderParamsResult = {
    builderParam: undefined,
    regularParams: []
  };

  // 如果没有 @BuilderParam 装饰器，添加 __builder__ 参数
  if (!hasBuilderParam) {
    result.builderParam = ts.factory.createParameterDeclaration(
      undefined,
      undefined,
      "__builder__",
      undefined,
      undefined,
      ts.factory.createIdentifier("undefined")
    );
  }

  // 收集常规参数
  params.forEach(param => {
    if (!hasBuilderParamDecorator(param)) {
      result.regularParams.push(param);
    }
  });

  return result;
}
```

#### 模式2：@Entry 装饰器验证与导出

**来源：** `compiler/src/process_ui_syntax.ts`

```typescript
// createEntryNode 函数处理 @Entry 组件的导出
function createEntryNode(node: ts.SourceFile, context: ts.TransformationContext,
  entryNodeKey: ts.Expression, id: number): ts.SourceFile {

  if (componentCollection.entryComponent) {
    // 创建 entry function
    const entryNode = createEntryFunction(
      componentCollection.entryComponent,
      context,
      cardRelativePath,
      entryNodeKey,
      id
    );

    // 将 entry function 添加到源文件
    return context.factory.updateSourceFile(
      node,
      [...node.statements, entryNode]
    );
  }

  return node;
}

// entryKeyNode 函数提取 @Entry 参数
function entryKeyNode(node: ts.Node): ts.Expression {
  const decorators = ts.getAllDecorators(node);
  if (node && decorators && decorators.length) {
    decorators.forEach(item => {
      if (item.expression && ts.isCallExpression(item.expression) &&
        ts.isIdentifier(item.expression.expression) &&
        item.expression.expression.escapedText.toString() === 'Entry') {

        // 提取 entry key 参数
        if (item.expression.arguments &&
          item.expression.arguments.length &&
          ts.isIdentifier(item.expression.arguments[0])) {
          entryNodeKey = item.expression.arguments[0];
        }
      }
    });
  }
  return entryNodeKey;
}
```

#### 模式3：资源引用转换

**来源：** `compiler/src/process_ui_syntax.ts`

```typescript
// RESOURCE 类型常量定义
export const RESOURCE_TYPE = {
  color: 10001,
  float: 10002,
  string: 10003,
  plural: 10004,
  boolean: 10005,
  intarray: 10006,
  integer: 10007,
  pattern: 10008,
  strarray: 10009,
  media: 10010,
  font: 10011,
  profile: 10012,
  rawfile: -1
};

// processResourceData 函数处理 $r() 调用
export function processResourceData(node: ts.CallExpression, filePath: string): ts.Node {
  const resourceData: string[] = node.arguments[0].text.trim().split('.');

  // 解析资源类型: $r('app.string.name') -> type: 10003, name: 'name'
  let resourceType: number = RESOURCE_TYPE[resourceData[1]];

  // 创建资源对象字面量
  const propertyArray: ts.PropertyAssignment[] = [
    ts.factory.createPropertyAssignment(
      ts.factory.createStringLiteral(RESOURCE_NAME_ID),
      ts.factory.createNumericLiteral(resourceValue)
    ),
    ts.factory.createPropertyAssignment(
      ts.factory.createStringLiteral(RESOURCE_NAME_TYPE),
      ts.factory.createNumericLiteral(resourceType)
    ),
    ts.factory.createPropertyAssignment(
      ts.factory.createIdentifier(RESOURCE_NAME_PARAMS),
      ts.factory.createArrayLiteralExpression(Array.from(node.arguments))
    )
  ];

  return ts.factory.createCallExpression(
    ts.factory.createIdentifier(__GETRESOURCEID__),
    undefined,
    [ts.factory.createObjectLiteralExpression(propertyArray)]
  );
}

// $rawfile() 处理
function isResourcefile(node: ts.CallExpression): ts.Node {
  // $rawfile('icon.png') -> __getRawFileId__("icon.png")
  return ts.factory.createCallExpression(
    ts.factory.createIdentifier("__getRawFileId__"),
    undefined,
    [node.arguments[0]]
  );
}
```

#### 模式4：状态属性初始化

**来源：** `compiler/src/process_component_class.ts`

```typescript
// @State 属性转换示例
// 源代码: @State count: number = 0;
// 输出:
//   count__: ObservedPropertySimple<number>;
//   get count() { return this.count__.get(); }
//   set count(newValue) { this.count__.set(newValue); }
//   constructor() {
//     this.count__ = new ObservedPropertySimple(0, this);
//   }

function processStateProperty(node: ts.PropertyDeclaration): ts.PropertyDeclaration {
  const propertyName = node.name.getText();
  const privateName = propertyName + "__";
  const initializer = node.initializer;

  // 1. 创建私有属性
  const privateProperty = ts.factory.createPropertyDeclaration(
    undefined,
    privateName,
    undefined,
    ts.factory.createTypeReferenceNode("ObservedPropertySimple", [node.type]),
    ts.factory.createNewExpression(
      ts.factory.createIdentifier("ObservedPropertySimple"),
      [node.type],
      [initializer, ts.factory.createThis()]
    )
  );

  // 2. 创建 getter
  const getter = ts.factory.createGetAccessorDeclaration(
    undefined,
    propertyName,
    [],
    undefined,
    ts.factory.createBlock([
      ts.factory.createReturnStatement(
        ts.factory.createPropertyAccessExpression(
          ts.factory.createPropertyAccessExpression(
            ts.factory.createThis(),
            privateName
          ),
          "get"
        )
      )
    ])
  );

  // 3. 创建 setter
  const setter = ts.factory.createSetAccessorDeclaration(
    undefined,
    propertyName,
    [ts.factory.createParameterDeclaration(undefined, undefined, "newValue")],
    ts.factory.createBlock([
      ts.factory.createExpressionStatement(
        ts.factory.createCallExpression(
          ts.factory.createPropertyAccessExpression(
            ts.factory.createPropertyAccessExpression(
              ts.factory.createThis(),
              privateName
            ),
            "set"
          ),
          undefined,
          [ts.factory.createIdentifier("newValue")]
        )
      )
    ])
  );

  return { privateProperty, getter, setter };
}
```

---

## 二、ets2jsc 项目架构

### 2.1 现有三层架构

```
┌─────────────────────────────────────────────────────────────┐
│  ets2jsc 编译器架构                                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  第1层: parse-ets.js (TypeScript Compiler API)             │
│  ─────────────────────────────────────────                  │
│  - 使用 typescript-parser 解析 ETS 源码                     │
│  - 生成 JSON 格式的 AST                                     │
│  - 提取节点的 text 属性保留原始代码                          │
│                                                             │
│  第2层: Converter (Java)                                    │
│  ─────────────────────                                      │
│  - 将 JSON AST 转换为内部 AST 表示                          │
│  - 表达式: expressions/*.java                               │
│  - 语句: statements/*.java                                  │
│                                                             │
│  第3层: CodeGenerator (Java)                                │
│  ─────────────────────────────                              │
│  - 遍历内部 AST 生成 JavaScript 代码                        │
│  - 处理缩进、格式化                                         │
│  - 输出到目标文件                                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 现有 Converter 目录结构

```
src/main/java/com/ets2jsc/parser/internal/converters/
├── expressions/               # 表达式转换器
│   ├── ArrayLiteralConverter.java
│   ├── ArrowFunctionConverter.java
│   ├── CallExpressionConverter.java
│   └── ...
└── statements/                # 语句转换器
    ├── BlockConverter.java
    ├── ClassDeclarationConverter.java
    ├── ForConverter.java
    ├── MethodDeclarationConverter.java
    └── ...
```

### 2.3 现有 CodeGenerator 架构

```java
public class CodeGenerator implements AstVisitor<String> {
    // 缩进管理
    private int currentIndent;
    private final String indent;

    // 状态管理
    private boolean insideComponentClass;

    // 生成方法
    public String generate(SourceFile sourceFile);
    public String visit(ClassDeclaration node);
    public String visit(MethodDeclaration node);
    public String visit(PropertyDeclaration node);
    // ...
}
```

---

## 三、需求实现方案

### 需求 #1: @Builder 装饰器方法

#### 1.1 实现概述

@Builder 装饰器方法需要：
1. 添加 `__builder__: BuilderParam = undefined` 作为第一个参数
2. 方法体内的组件调用转换为 create/pop 模式
3. 调用点需要包装 BuilderParam 逻辑

#### 1.2 实现位置

**新增文件：** `src/main/java/com/ets2jsc/ast/BuilderMethodDeclaration.java`

```java
package com.ets2jsc.ast;

import java.util.List;

/**
 * AST node for @Builder decorated methods.
 * Extends MethodDeclaration with builder-specific properties.
 */
public class BuilderMethodDeclaration extends MethodDeclaration {
    private boolean hasBuilderParam;
    private String builderParamName = "__builder__";

    public BuilderMethodDeclaration(String name) {
        super(name);
        this.hasBuilderParam = false;
    }

    public boolean isBuilderMethod() {
        return hasDecorator("Builder");
    }

    public String getBuilderParamName() {
        return builderParamName;
    }

    public void setBuilderParamName(String name) {
        this.builderParamName = name;
    }
}
```

#### 1.3 修改 MethodDeclarationConverter

**文件：** `src/main/java/com/ets2jsc/parser/internal/converters/statements/MethodDeclarationConverter.java`

```java
@Override
public Object convert(JsonObject json, ConversionContext context) {
    String name = json.get("name").getAsString();

    // 检查是否有 @Builder 装饰器
    JsonArray decoratorsArray = json.getAsJsonArray("decorators");
    boolean isBuilderMethod = false;
    if (decoratorsArray != null) {
        for (int i = 0; i < decoratorsArray.size(); i++) {
            JsonObject decObj = decoratorsArray.get(i).getAsJsonObject();
            String decName = decObj.get("name").getAsString();
            if ("Builder".equals(decName)) {
                isBuilderMethod = true;
                break;
            }
        }
    }

    MethodDeclaration methodDecl;
    if (isBuilderMethod) {
        methodDecl = new BuilderMethodDeclaration(name);
    } else {
        methodDecl = new MethodDeclaration(name);
    }

    // 转换装饰器
    if (decoratorsArray != null) {
        for (int i = 0; i < decoratorsArray.size(); i++) {
            JsonObject decObj = decoratorsArray.get(i).getAsJsonObject();
            String decName = decObj.get("name").getAsString();
            methodDecl.addDecorator(new Decorator(decName));
        }
    }

    // 转换参数
    JsonArray paramsArray = json.getAsJsonArray("parameters");
    if (paramsArray != null) {
        List<MethodDeclaration.Parameter> params = new ArrayList<>();

        // @Builder 方法：添加 __builder__ 参数作为第一个参数
        if (isBuilderMethod) {
            MethodDeclaration.Parameter builderParam = new MethodDeclaration.Parameter(
                "__builder__",
                "BuilderParam"
            );
            builderParam.setDefaultValue("undefined");
            params.add(builderParam);
        }

        for (int i = 0; i < paramsArray.size(); i++) {
            JsonObject paramObj = paramsArray.get(i).getAsJsonObject();
            String paramName = paramObj.get("name").getAsString();
            String paramType = paramObj.has("type") ? paramObj.get("type").getAsString() : "";
            MethodDeclaration.Parameter param = new MethodDeclaration.Parameter(paramName, paramType);
            params.add(param);
        }

        methodDecl.setParameters(params);
    }

    // ... 其他处理

    return methodDecl;
}
```

#### 1.4 修改 CodeGenerator

**文件：** `src/main/java/com/ets2jsc/generator/CodeGenerator.java`

```java
@Override
public String visit(MethodDeclaration node) {
    StringBuilder sb = new StringBuilder();
    sb.append(getIndent());

    // 处理 @Builder 方法
    if (node instanceof BuilderMethodDeclaration) {
        BuilderMethodDeclaration builderMethod = (BuilderMethodDeclaration) node;

        sb.append(builderMethod.getName()).append("(");

        // 第一个参数是 __builder__
        sb.append(builderMethod.getBuilderParamName())
          .append(" = undefined");

        // 其他参数
        List<MethodDeclaration.Parameter> params = node.getParameters();
        for (int i = 1; i < params.size(); i++) {
            sb.append(", ").append(params.get(i).getName());
        }

        sb.append(") {\n");
        currentIndent++;

        // 方法体 - 组件调用已在 BlockConverter 中转换为 create/pop 模式
        if (node.getBody() != null) {
            String bodyCode = node.getBody().accept(this);
            sb.append(bodyCode);
        }

        currentIndent--;
        sb.append(getIndent()).append("}\n");

        return sb.toString();
    }

    // 常规方法处理...
    // ... 现有代码
}
```

#### 1.5 调用点转换

**新增类：** `src/main/java/com/ets2jsc/transformer/BuilderCallTransformer.java`

```java
package com.ets2jsc.transformer;

import com.ets2jsc.ast.CallExpression;
import com.google.gson.JsonObject;

/**
 * Transformer for @Builder method calls.
 * Converts: TabBar(0, "home", "首页")
 * To: const __builder__ = new BuilderParam();
 *     this.TabBar(__builder__, 0, "home", "首页");
 *     __builder__.build();
 */
public class BuilderCallTransformer {

    public static String transform(String methodName, String args) {
        StringBuilder sb = new StringBuilder();

        // 创建 BuilderParam 对象
        sb.append("const __builder__ = new BuilderParam();\n");
        sb.append(getIndent());

        // 调用 @Builder 方法，传入 __builder__ 作为第一个参数
        sb.append("this.").append(methodName).append("(__builder__");

        if (!args.isEmpty() && !args.equals("()")) {
            // 移除括号并添加参数
            String argsContent = args.substring(1, args.length() - 1).trim();
            if (!argsContent.isEmpty()) {
                sb.append(", ").append(argsContent);
            }
        }

        sb.append(");\n");
        sb.append(getIndent());

        // 调用 build()
        sb.append("__builder__.build();");

        return sb.toString();
    }
}
```

---

### 需求 #2: @Entry 装饰器验证与导出

#### 2.1 实现概述

@Entry 装饰器的处理已经在 `ClassDeclarationConverter` 中部分实现，需要完善验证逻辑。

#### 2.2 增强 ClassDeclarationConverter

**文件：** `src/main/java/com/ets2jsc/parser/internal/converters/statements/ClassDeclarationConverter.java`

```java
@Override
public Object convert(JsonObject json, ConversionContext context) {
    String name = json.get("name").getAsString();
    ClassDeclaration classDecl = new ClassDeclaration(name);

    // 转换装饰器并验证
    JsonArray decoratorsArray = json.getAsJsonArray("decorators");
    boolean hasEntryDecorator = false;
    boolean hasComponentDecorator = false;

    if (decoratorsArray != null) {
        for (int i = 0; i < decoratorsArray.size(); i++) {
            JsonObject decObj = decoratorsArray.get(i).getAsJsonObject();
            String decName = decObj.get("name").getAsString();
            classDecl.addDecorator(new Decorator(decName));

            if ("Entry".equals(decName)) {
                hasEntryDecorator = true;
            }
            if ("Component".equals(decName)) {
                hasComponentDecorator = true;
            }
        }
    }

    // 验证 @Entry 只能与 @Component 一起使用
    if (hasEntryDecorator && !hasComponentDecorator) {
        context.error("@Entry decorator can only be used with @Component decorator",
            json.get("pos").getAsInt());
    }

    // 设置导出标志
    boolean isExported = json.has("isExport") && json.get("isExport").getAsBoolean();
    if (isExported) {
        classDecl.setExport(true);
    } else if (hasEntryDecorator) {
        // @Entry 组件必须导出 - 自动添加 export
        classDecl.setExport(true);
    }

    // ... 其他处理

    return classDecl;
}
```

#### 2.3 添加验证支持

**新增类：** `src/main/java/com/ets2jsc/validator/DecoratorValidator.java`

```java
package com.ets2jsc.validator;

import com.google.gson.JsonObject;
import com.ets2jsc.parser.internal.ConversionContext;

/**
 * Validator for ETS decorators.
 */
public class DecoratorValidator {

    /**
     * 验证 @Entry 装饰器使用规则
     */
    public static boolean validateEntryDecorator(JsonObject classDecl, ConversionContext context) {
        JsonArray decorators = classDecl.getAsJsonArray("decorators");
        if (decorators == null) {
            return true;
        }

        boolean hasEntry = false;
        boolean hasComponent = false;

        for (int i = 0; i < decorators.size(); i++) {
            JsonObject decorator = decorators.get(i).getAsJsonObject();
            String name = decorator.get("name").getAsString();

            if ("Entry".equals(name)) {
                hasEntry = true;
            }
            if ("Component".equals(name)) {
                hasComponent = true;
            }
        }

        if (hasEntry && !hasComponent) {
            int pos = classDecl.has("name") ? classDecl.get("name").getAsJsonObject().get("pos").getAsInt() : 0;
            context.error("@Entry decorator must be used with @Component decorator", pos);
            return false;
        }

        return true;
    }
}
```

---

### 需求 #3: 资源引用处理

#### 3.1 实现概述

资源引用 `$r()` 和 `$rawfile()` 需要转换为运行时函数调用。

#### 3.2 添加常量定义

**文件：** `src/main/java/com/ets2jsc/constant/Resources.java`

```java
package com.ets2jsc.constant;

/**
 * 资源类型常量定义
 */
public class Resources {

    // 资源类型 ID
    public static final int COLOR = 10001;
    public static final int FLOAT = 10002;
    public static final int STRING = 10003;
    public static final int PLURAL = 10004;
    public static final int BOOLEAN = 10005;
    public static final int INTARRAY = 10006;
    public static final int INTEGER = 10007;
    public static final int PATTERN = 10008;
    public static final int STRARRAY = 10009;
    public static final int MEDIA = 10010;
    public static final int FONT = 10011;
    public static final int PROFILE = 10012;
    public static final int RAWFILE = -1;

    // 资源类型名称映射
    public static int getResourceTypeId(String typeName) {
        switch (typeName) {
            case "color": return COLOR;
            case "float": return FLOAT;
            case "string": return STRING;
            case "plural": return PLURAL;
            case "boolean": return BOOLEAN;
            case "intarray": return INTARRAY;
            case "integer": return INTEGER;
            case "pattern": return PATTERN;
            case "strarray": return STRARRAY;
            case "media": return MEDIA;
            case "font": return FONT;
            case "profile": return PROFILE;
            case "rawfile": return RAWFILE;
            default: return -1;
        }
    }
}
```

#### 3.3 新增资源表达式转换器

**新增文件：** `src/main/java/com/ets2jsc/parser/internal/converters/expressions/ResourceExpressionConverter.java`

```java
package com.ets2jsc.parser.internal.converters.expressions;

import com.ets2jsc.constant.Resources;
import com.ets2jsc.parser.internal.ConversionContext;
import com.ets2jsc.parser.internal.NodeConverter;
import com.google.gson.JsonObject;
import java.util.regex.Pattern;

/**
 * Converter for resource reference expressions.
 * Handles: $r('app.type.name'), $rawfile('filename')
 */
public class ResourceExpressionConverter implements NodeConverter {

    private static final Pattern RESOURCE_PATTERN = Pattern.compile("^\\s*['\"]([\\w.]+)['\"]\\s*$");

    @Override
    public boolean canConvert(String kindName) {
        return "ResourceExpression".equals(kindName) ||
               "RawfileExpression".equals(kindName);
    }

    @Override
    public Object convert(JsonObject json, ConversionContext context) {
        String kindName = json.has("kindName") ? json.get("kindName").getAsString() : "";

        if ("RawfileExpression".equals(kindName) ||
            (json.has("expression") && "$rawfile".equals(json.get("expression").getAsString()))) {

            return convertRawfile(json);
        }

        return convertResource(json);
    }

    /**
     * 转换 $r('app.type.name') 为 __getResourceId__(type, bundle, module, name)
     */
    private String convertResource(JsonObject json) {
        String resourcePath = json.get("argument").getAsString();

        // 解析资源路径: "app.string.name" -> ["app", "string", "name"]
        String[] parts = resourcePath.split("\\.");

        if (parts.length < 3) {
            // 格式错误，返回原样
            return "$r(" + resourcePath + ")";
        }

        String moduleName = parts[0];     // "app"
        String typeName = parts[1];       // "string"
        String resourceName = parts[2];   // "name"

        int typeId = Resources.getResourceTypeId(typeName);

        // 生成: __getResourceId__(type, bundle, module, name)
        return String.format("__getResourceId__(%d, undefined, \"%s\", \"%s\")",
            typeId, moduleName, resourceName);
    }

    /**
     * 转换 $rawfile('filename') 为 __getRawFileId__("filename")
     */
    private String convertRawfile(JsonObject json) {
        String filename = json.get("argument").getAsString();

        // 生成: __getRawFileId__("filename")
        return "__getRawFileId__(\"" + filename + "\")";
    }
}
```

#### 3.4 注册资源表达式转换器

**文件：** `src/main/java/com/ets2jsc/parser/internal/ConversionContext.java`

```java
// 在 getExpressionConverter 方法中添加
private NodeConverter getExpressionConverter(String kindName) {
    // ... 现有代码

    if ("ResourceExpression".equals(kindName) ||
        "RawfileExpression".equals(kindName)) {
        return new ResourceExpressionConverter();
    }

    // ... 其他处理
}
```

---

### 需求 #4: 跳转语句 (break, continue)

#### 4.1 实现概述

break/continue 语句是标准 JavaScript 语法，应保留原样。

#### 4.2 新增跳转语句转换器

**新增文件：** `src/main/java/com/ets2jsc/parser/internal/converters/statements/BreakConverter.java`

```java
package com.ets2jsc.parser.internal.converters.statements;

import com.ets2jsc.parser.internal.ConversionContext;
import com.ets2jsc.parser.internal.NodeConverter;
import com.google.gson.JsonObject;

/**
 * Converter for break statements.
 */
public class BreakConverter implements NodeConverter {

    @Override
    public boolean canConvert(String kindName) {
        return "BreakStatement".equals(kindName);
    }

    @Override
    public Object convert(JsonObject json, ConversionContext context) {
        StringBuilder sb = new StringBuilder();
        sb.append("break");

        // 带标签的 break
        if (json.has("label") && !json.get("label").isJsonNull()) {
            String label = json.get("label").getAsString();
            sb.append(" ").append(label);
        }

        sb.append(";");
        return sb.toString();
    }
}
```

**新增文件：** `src/main/java/com/ets2jsc/parser/internal/converters/statements/ContinueConverter.java`

```java
package com.ets2jsc.parser/internal/converters/statements;

import com.ets2jsc.parser.internal.ConversionContext;
import com.ets2jsc.parser.internal.NodeConverter;
import com.google.gson.JsonObject;

/**
 * Converter for continue statements.
 */
public class ContinueConverter implements NodeConverter {

    @Override
    public boolean canConvert(String kindName) {
        return "ContinueStatement".equals(kindName);
    }

    @Override
    public Object convert(JsonObject json, ConversionContext context) {
        StringBuilder sb = new StringBuilder();
        sb.append("continue");

        // 带标签的 continue
        if (json.has("label") && !json.get("label").isJsonNull()) {
            String label = json.get("label").getAsString();
            sb.append(" ").append(label);
        }

        sb.append(";");
        return sb.toString();
    }
}
```

---

### 需求 #5: JSDoc 注释保留

#### 5.1 实现概述

TypeScript Compiler API 默认会保留 JSDoc 注释。需要在 parse-ets.js 中确保注释被提取，并在 CodeGenerator 中输出。

#### 5.2 修改 parse-ets.js

**文件：** `src/main/resources/typescript-parser/parse-ets.js`

```javascript
// 在节点处理函数中添加 comments 提取
function processNode(node) {
  const result = {
    kindName: ts.SyntaxKind[node.kind],
    // ... 其他属性
  };

  // 提取 JSDoc 注释
  if (node.jsDocCache && node.jsDocCache.length > 0) {
    result.jsDoc = node.jsDocCache.map(doc => ({
      tags: doc.tags ? doc.tags.map(tag => ({
        name: tag.tagName.text,
        text: tag.comment || ""
      })) : [],
      comment: doc.comment || ""
    }));
  }

  return result;
}
```

#### 5.3 修改 CodeGenerator

**文件：** `src/main/java/com/ets2jsc/generator/CodeGenerator.java`

```java
// 添加 JSDoc 生成方法
private String generateJSDoc(AstNode node) {
    if (!node.hasJSDoc()) {
        return "";
    }

    List<JSDocComment> comments = node.getJSDocComments();
    if (comments.isEmpty()) {
        return "";
    }

    StringBuilder sb = new StringBuilder();
    sb.append(getIndent()).append("/**\n");

    for (JSDocComment doc : comments) {
        // 添加描述
        if (doc.getComment() != null && !doc.getComment().isEmpty()) {
            sb.append(getIndent()).append(" * ")
              .append(doc.getComment()).append("\n");
        }

        // 添加标签
        for (JSDocTag tag : doc.getTags()) {
            sb.append(getIndent()).append(" * @")
              .append(tag.getName());
            if (tag.getText() != null && !tag.getText().isEmpty()) {
                sb.append(" ").append(tag.getText());
            }
            sb.append("\n");
        }
    }

    sb.append(getIndent()).append(" */\n");
    return sb.toString();
}

// 在 visit(MethodDeclaration) 和 visit(ClassDeclaration) 等方法中使用
@Override
public String visit(MethodDeclaration node) {
    StringBuilder sb = new StringBuilder();

    // 添加 JSDoc
    sb.append(generateJSDoc(node));

    // ... 现有代码
}
```

---

### 需求 #6: 泛型语法处理

#### 6.1 实现概述

泛型语法需要从输出中移除，因为 JavaScript 不支持泛型。

#### 6.2 修改相关转换器

**文件：** `src/main/java/com/ets2jsc/parser/internal/converters/FunctionDeclarationConverter.java`

```java
@Override
public Object convert(JsonObject json, ConversionContext context) {
    String name = json.get("name").getAsString();

    // 移除泛型参数
    // 源代码: function identity<T>(arg: T): T
    // 输出: function identity(arg)

    FunctionDeclaration funcDecl = new FunctionDeclaration(name);

    // 转换参数（移除类型注解）
    JsonArray paramsArray = json.getAsJsonArray("parameters");
    if (paramsArray != null) {
        for (int i = 0; i < paramsArray.size(); i++) {
            JsonObject paramObj = paramsArray.get(i).getAsJsonObject();
            String paramName = paramObj.get("name").getAsString();
            // 不提取 type，因为泛型类型在 JS 中无效
            funcDecl.addParameter(paramName);
        }
    }

    // ... 其他处理

    return funcDecl;
}
```

**文件：** `src/main/java/com/ets2jsc/parser/internal/converters/statements/ClassDeclarationConverter.java`

```java
@Override
public Object convert(JsonObject json, ConversionContext context) {
    String name = json.get("name").getAsString();
    ClassDeclaration classDecl = new ClassDeclaration(name);

    // 移除类名后的泛型参数
    // 源代码: class Container<T>
    // 输出: class Container

    // ... 其他处理

    return classDecl;
}
```

---

### 需求 #7: for 循环完整支持

#### 7.1 实现概述

for 循环是标准 JavaScript 语法，现有 `ForConverter` 已支持，需要增强以支持多变量和省略情况。

#### 7.2 增强 ForConverter

**文件：** `src/main/java/com/ets2jsc/parser/internal/converters/statements/ForConverter.java`

```java
@Override
protected String getLoopHeader(JsonObject json, ConversionContext context) {
    JsonObject initializer = json.getAsJsonObject("initializer");
    JsonObject condition = json.getAsJsonObject("condition");
    JsonObject incrementor = json.getAsJsonObject("incrementor");

    String initStr = "";
    if (initializer != null) {
        initStr = context.convertExpression(initializer);
    }

    String condStr = "";
    if (condition != null) {
        condStr = context.convertExpression(condition);
    }

    String incrStr = "";
    if (incrementor != null) {
        incrStr = context.convertExpression(incrementor);
    }

    StringBuilder sb = new StringBuilder();
    sb.append("for (").append(initStr).append("; ");
    sb.append(condStr).append("; ");
    sb.append(incrStr).append(") {\n");

    return sb.toString();
}
```

---

### 需求 #8: async 方法转换

#### 8.1 实现概述

async 方法需要保留 async 关键字。

#### 8.2 确认现有实现

**文件：** `src/main/java/com/ets2jsc/parser/internal/converters/statements/MethodDeclarationConverter.java`

现有实现已经正确处理 async 关键字：

```java
// 转换修饰符 (static, async, etc.)
JsonArray modifiersArray = json.getAsJsonArray("modifiers");
if (modifiersArray != null) {
    for (int i = 0; i < modifiersArray.size(); i++) {
        JsonObject modObj = modifiersArray.get(i).getAsJsonObject();
        String modKindName = modObj.has("kindName") ? modObj.get("kindName").getAsString() : "";

        if ("AsyncKeyword".equals(modKindName) || "async".equals(modKindName)) {
            methodDecl.setAsync(true);
        }
    }
}
```

**文件：** `src/main/java/com/ets2jsc/generator/CodeGenerator.java`

```java
// Add async keyword if present
if (node.isAsync()) {
    sb.append("async ");
}
```

---

### 需求 #9: 属性链式调用主体绑定

#### 9.1 实现概述

此需求涉及运行时行为，需要根据状态属性的实现具体分析。

**注：** 此需求较复杂，建议在状态属性初始化（需求#10）完成后再实现。

---

### 需求 #10: 状态属性初始化

#### 10.1 实现概述

状态属性（@State/@Prop/@Link）需要生成包装属性和初始化逻辑。

#### 10.2 修改 AST 节点

**文件：** `src/main/java/com/ets2jsc/ast/PropertyDeclaration.java`

```java
public class PropertyDeclaration extends AstNode {
    private String name;
    private String type;
    private String initializer;
    private String decorator;  // @State, @Prop, @Link

    // 状态属性特有
    private boolean isStateProperty;
    private String privateName;  // name__
    private String wrapperType;  // ObservedPropertySimple, etc.

    // getter/setter
}
```

#### 10.3 修改 PropertyDeclarationConverter

**文件：** `src/main/java/com/ets2jsc/parser/internal/converters/statements/PropertyDeclarationConverter.java`

```java
@Override
public Object convert(JsonObject json, ConversionContext context) {
    String name = json.get("name").getAsString();
    PropertyDeclaration propDecl = new PropertyDeclaration(name);

    // 检查装饰器
    JsonArray decoratorsArray = json.getAsJsonArray("decorators");
    if (decoratorsArray != null) {
        for (int i = 0; i < decoratorsArray.size(); i++) {
            JsonObject decObj = decoratorsArray.get(i).getAsJsonObject();
            String decName = decObj.get("name").getAsString();
            propDecl.addDecorator(new Decorator(decName));

            // 设置状态属性标记
            if ("State".equals(decName)) {
                propDecl.setStateProperty(true);
                propDecl.setPrivateName(name + "__");
                propDecl.setWrapperType("ObservedPropertySimple");
            } else if ("Prop".equals(decName)) {
                propDecl.setStateProperty(true);
                propDecl.setPrivateName(name + "__");
                propDecl.setWrapperType("SynchedPropertySimpleOneWay");
            } else if ("Link".equals(decName)) {
                propDecl.setStateProperty(true);
                propDecl.setPrivateName(name + "__");
                propDecl.setWrapperType("SynchedPropertySimpleTwoWay");
            }
        }
    }

    // ... 其他处理

    return propDecl;
}
```

#### 10.4 修改 CodeGenerator

**文件：** `src/main/java/com/ets2jsc/generator/CodeGenerator.java`

```java
@Override
public String visit(PropertyDeclaration node) {
    StringBuilder sb = new StringBuilder();
    sb.append(getIndent());

    if (node.isStateProperty()) {
        // 生成私有属性
        sb.append(node.getPrivateName()).append(": ")
          .append(node.getWrapperType()).append("<")
          .append(node.getType()).append(">");

        if (node.getInitializer() != null) {
            if ("State".equals(node.getDecorator())) {
                sb.append(" = new ")
                  .append(node.getWrapperType())
                  .append("(")
                  .append(node.getInitializer())
                  .append(", this);");
            } else if ("Prop".equals(node.getDecorator())) {
                sb.append(" = this.createProp(\"")
                  .append(node.getName())
                  .append("\", () => this.")
                  .append(node.getName())
                  .append(");");
            } else if ("Link".equals(node.getDecorator())) {
                sb.append(" = this.createLink(\"")
                  .append(node.getName())
                  .append("\", () => this.")
                  .append(node.getName())
                  .append(");");
            }
        }
        sb.append("\n");

        // 生成 getter
        sb.append(getIndent()).append("get ")
          .append(node.getName()).append("() {\n");
        currentIndent++;
        sb.append(getIndent()).append("return this.")
          .append(node.getPrivateName()).append(".get();\n");
        currentIndent--;
        sb.append(getIndent()).append("}\n");

        // 生成 setter
        sb.append(getIndent()).append("set ")
          .append(node.getName()).append("(newValue) {\n");
        currentIndent++;
        sb.append(getIndent()).append("this.")
          .append(node.getPrivateName()).append(".set(newValue);\n");
        currentIndent--;
        sb.append(getIndent()).append("}\n");

    } else {
        // 常规属性处理
        sb.append(node.getName());
        if (node.getInitializer() != null) {
            sb.append(" = ").append(node.getInitializer());
        }
        sb.append(";\n");
    }

    return sb.toString();
}
```

#### 10.5 修改构造函数生成

需要在 `ClassDeclarationConverter` 中收集状态属性，然后在构造函数中生成初始化逻辑。

---

## 四、代码质量问题修复方案

### 问题 #1: async 箭头函数转换丢失 async 关键字

#### 修复方案

**文件：** `src/main/java/com/ets2jsc/parser/internal/converters/expressions/ArrowFunctionConverter.java`

```java
@Override
public Object convert(JsonObject json, ConversionContext context) {
    StringBuilder sb = new StringBuilder();

    // 检查 async 修饰符
    boolean isAsync = false;
    JsonArray modifiersArray = json.getAsJsonArray("modifiers");
    if (modifiersArray != null) {
        for (int i = 0; i < modifiersArray.size(); i++) {
            JsonObject modObj = modifiersArray.get(i).getAsJsonObject();
            String modKindName = modObj.has("kindName") ? modObj.get("kindName").getAsString() : "";
            if ("AsyncKeyword".equals(modKindName)) {
                isAsync = true;
                break;
            }
        }
    }

    // 添加 async 关键字
    if (isAsync) {
        sb.append("async ");
    }

    // 获取参数和函数体
    // ... 现有代码

    return sb.toString();
}
```

### 问题 #2: 代码缩进格式不正确

#### 修复方案

**文件：** `src/main/java/com/ets2jsc/generator/CodeGenerator.java`

```java
@Override
public String visit(MethodDeclaration node) {
    StringBuilder sb = new StringBuilder();
    sb.append(getIndent());

    // 方法签名
    // ...

    sb.append(") {\n");
    currentIndent++;

    // 方法体
    if (node.getBody() != null) {
        String bodyCode = node.getBody().accept(this);
        // 确保函数体内容正确缩进
        if (node.getBody() instanceof Block) {
            sb.append(bodyCode);
        } else {
            // 单表达式函数体
            sb.append(getIndent()).append(bodyCode).append("\n");
        }
    }

    currentIndent--;
    sb.append(getIndent()).append("}\n");

    return sb.toString();
}
```

### 问题 #3: 输出产物未保持原始目录结构

#### 修复方案

**文件：** `src/main/java/com/ets2jsc/EtsCompiler.java`

```java
private String getOutputPath(String sourcePath) {
    // 保持源代码目录结构
    Path sourcePathObj = Paths.get(sourcePath);
    Path relativePath = projectRootPath.relativize(sourcePathObj);

    // 构建 dist 目录下的相同结构
    Path outputPath = Paths.get(distDir).resolve(relativePath);

    // 修改文件扩展名
    String outputFileName = outputPath.getFileName().toString()
        .replace(".ets", ".js")
        .replace(".ts", ".js");

    return outputPath.getParent().resolve(outputFileName).toString();
}
```

---

## 五、实现优先级与依赖关系

### 5.1 第一阶段（P0 - 必须立即修复）

1. **问题 #1**: async 箭头函数转换丢失 async 关键字
2. **问题 #2**: 代码缩进格式不正确
3. **需求 #1**: @Builder 装饰器方法
4. **需求 #2**: @Entry 装饰器验证与导出
5. **需求 #3**: 资源引用处理

### 5.2 第二阶段（P1 - 尽快实现）

6. **需求 #10**: 状态属性初始化
7. **需求 #4**: 跳转语句
8. **需求 #7**: for 循环完整支持
9. **需求 #8**: async 方法转换（确认现有实现）

### 5.3 第三阶段（P1 - 补充功能）

10. **需求 #5**: JSDoc 注释保留
11. **需求 #6**: 泛型语法处理
12. **需求 #9**: 属性链式调用主体绑定
13. **问题 #3**: 输出产物目录结构
14. **问题 #4**: const 变量声明缺少初始化器

### 5.4 第四阶段（P2 - 可选优化）

15. **需求 #11**: 可选链和空值合并
16. **需求 #12**: 解构赋值
17. **需求 #13**: 生成器函数
18. **问题 #5**: 类字段声明格式不一致

---

## 六、测试用例

### 6.1 @Builder 方法测试

**输入：**
```typescript
@Component
struct Index {
  @Builder
  TabBar(index: number, icon: string, label: string) {
    Column() {
      Text(icon)
      Text(label)
    }
  }

  build() {
    TabBar(0, "home", "首页")
  }
}
```

**预期输出：**
```javascript
export class Index extends View {
  TabBar(__builder__ = undefined, index, icon, label) {
    Column.create();
    Text.create(icon);
    Text.pop();
    Text.create(label);
    Text.pop();
    Column.pop();
  }

  render() {
    const __builder__ = new BuilderParam();
    this.TabBar(__builder__, 0, "home", "首页");
    __builder__.build();
  }
}
```

### 6.2 资源引用测试

**输入：**
```typescript
Text($r('app.string.name'))
Image($rawfile('icon.png'))
```

**预期输出：**
```javascript
Text.create(__getResourceId__(10003, undefined, "app", "name"));
Text.pop();
Image.create(__getRawFileId__("icon.png"));
Image.pop();
```

### 6.3 状态属性初始化测试

**输入：**
```typescript
@Component
struct MyComponent {
  @State count: number = 0;
  @Prop title: string = "Hello";

  build() {
    Text(`${this.title}: ${this.count}`)
  }
}
```

**预期输出：**
```javascript
export class MyComponent extends View {
  count__: ObservedPropertySimple<number> = new ObservedPropertySimple(0, this);
  title__: SynchedPropertySimpleOneWay<string> = this.createProp("title", () => this.title);

  get count() {
    return this.count__.get();
  }

  set count(newValue) {
    this.count__.set(newValue);
  }

  get title() {
    return this.title__.get();
  }

  set title(newValue) {
    this.title__.set(newValue);
  }

  render() {
    Text.create(`${this.title}: ${this.count}`);
    Text.pop();
  }
}
```

---

## 七、参考文档

1. **原始编译器实现**：`src/main/resources/developtools_ace_ets2bundle/compiler/src/`
2. **迭代2技术方案**：`docs/迭代2-技术实现方案-part1.md`
3. **迭代3技术方案**：`docs/迭代3-技术实现方案.md`
4. **迭代4技术方案**：`docs/迭代4-技术实现方案.md`
5. **TypeScript Compiler API**: https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API

---

**文档版本：** v1.0
**编写日期：** 2026-01-31
**文档状态：** 待评审
