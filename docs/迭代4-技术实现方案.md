# ETS 编译器迭代4技术实现方案说明书

## 文档版本历史

| 版本 | 日期 | 修改内容 | 修改人 |
|-----|------|---------|--------|
| v1.0 | 2026-01-30 | 基于原始编译器实现方案创建 | Claude AI Assistant |

---

## 一、原始编译器架构分析（迭代4特性）

### 1.1 核心设计原则

基于对 `src/main/resources/developtools_ace_ets2bundle` 的深入分析，针对迭代4需求的语法特性，原始编译器采用以下处理策略：

#### 原则1：现代 JavaScript 语法完全保留

**关键发现：** 原始编译器对于迭代4中的大多数语法特性，采用**完全保留**策略，因为这些是标准 ES6+ 语法，不是 ETS 特有语法。

**证据来源：**
- `compiler/src/process_ui_syntax.ts` 第444行：`return ts.visitEachChild(node, processAllNodes, context);`
- 标准的现代 JavaScript 语法通过 TypeScript Compiler API 的 emitter 自动输出

#### 原则2：ETS 特有装饰器需要特殊处理

对于 `@Entry`、`@Builder` 等装饰器，原始编译器有专门的转换逻辑。

### 1.2 语法分类处理策略（迭代4）

#### A类：ETS 特有语法（需要转换）

| 语法类型 | 处理方式 | 实现文件 |
|---------|---------|---------|
| `@Entry` 装饰器 | 验证并确保导出 | process_custom_component.ts |
| `@Builder` 方法 | 转换为 Builder 函数格式 | process_interop_builder.ts |
| `@Component` struct | 转换为 class + 导出处理 | process_ui_syntax.ts |

#### B类：标准 JavaScript/TypeScript 语法（保留原样）

| 语法类型 | 处理方式 | 说明 |
|---------|---------|-----|
| **对象字面量** | 保留原样 | `{ a: 1 }` |
| **NewExpression** | 保留原样 | `new Class()` |
| **模板字符串** | 保留原样 | `` `hello ${name}` `` |
| **箭头函数** | 保留原样 | `() => {}` |
| **async/await** | 保留原样 | `async () => await x` |
| **动态导入** | 保留原样 | `await import()` |
| **interface 声明** | 保留原样 | TypeScript 特有，运行时保留 |
| **类型注解** | 部分保留 | 变量声明类型保留，函数参数转为注释 |
| **类型断言** | 保留原样 | `x as Type` |
| **八进制字面量** | 保留原样 | `0o1` |
| **for-of/for** | 保留原样 | 标准循环语法 |

### 1.3 关键代码模式（原始编译器）

#### 模式1：对象字面量处理（process_ui_syntax.ts）

```typescript
// 原始编译器对对象字面量不做特殊处理
// 通过 ts.visitEachChild 自动遍历子节点
// 输出保持原样
```

#### 模式2：NewExpression 处理

```typescript
// 原始编译器使用 ts.factory.createNewExpression()
// 自动保留 new 表达式
if (ts isNewExpression(node)) {
    return ts.factory.createNewExpression(
        node.expression,
        node.typeArguments,
        node.arguments
    );
}
```

#### 模式3：@Entry 装饰器验证

**来源：** `compiler/src/check_ui_syntax.ts`

```typescript
// @Entry 装饰器的验证逻辑
function validateEntryDecorator(node: ts.ClassDeclaration) {
    const entryDecorator = getDecoratorByName(node, 'Entry');
    if (entryDecorator) {
        // 验证 @Entry 只能用于 @Component 装饰的 struct
        if (!hasComponentDecorator(node)) {
            error('@Entry must be used with @Component');
        }
        // 验证必须导出
        if (!isExported(node)) {
            error('@Entry component must be exported');
        }
    }
}
```

#### 模式4：@Builder 方法处理

**来源：** `compiler/src/process_interop_builder.ts`

```typescript
// @Builder 方法的转换
function processBuilderMethod(node: ts.MethodDeclaration) {
    const builderDecorator = getDecoratorByName(node, 'Builder');
    if (builderDecorator) {
        // 添加 __builder__ 参数
        const builderParam = ts.factory.createParameterDeclaration(
            undefined,
            undefined,
            "__builder__",
            undefined,
            ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword),
            ts.factory.createIdentifier("undefined")
        );

        // 修改参数列表
        const newParams = [builderParam, ...node.parameters.slice(1)];

        return ts.factory.updateMethodDeclaration(
            node,
            node.decorators,
            node.modifiers,
            node.asteriskToken,
            node.name,
            node.questionToken,
            node.typeParameters,
            newParams,
            node.type,
            node.body
        );
    }
}
```

---

## 二、ets2jsc 项目架构

### 2.1 现有三层架构

```
┌─────────────────────────────────────────────────────────────┐
│  ets2jsc 编译器架构                                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  第1层: parse-ets.js                                       │
│  ──────────────────────────────                            │
│  - 使用 TypeScript Compiler API 解析 ETS/TypeScript        │
│  - 预处理 ETS 语法（struct → class）                        │
│  - 将 AST 转换为 JSON 格式                                  │
│  - 输出: JSON AST                                          │
│                                                             │
│  第2层: TypeScriptScriptParser.java                         │
│  ────────────────────────────────────                        │
│  - 解析 JSON AST                                            │
│  - 构建 Java AST 节点                                       │
│  - 实现 ETS 特有语法的转换                                  │
│  - 实现 JS 表达式到字符串的转换                             │
│  - 输出: Java AST                                           │
│                                                             │
│  第3层: CodeGenerator                                       │
│  ───────────────────────                                    │
│  - 遍历 Java AST                                            │
│  - 生成 JavaScript 代码                                     │
│  - 输出: JavaScript 源码                                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 与原始编译器的关键差异（迭代4特性）

| 特性 | 原始编译器 | ets2jsc 编译器 | 迭代4实现策略 |
|-----|-----------|---------------|-------------|
| 对象字面量 | 自动保留 | 需正确序列化 | 修复 JSON 序列化 |
| NewExpression | 自动保留 | 需正确序列化 | 修复 JSON 序列化 |
| 模板字符串 | 自动保留 | 需正确序列化 | 修复 JSON 序列化 |
| 箭头函数 | 自动保留 | 需正确序列化 | 修复 JSON 序列化 |
| @Entry | 验证+导出 | 缺少导出 | 添加导出逻辑 |
| @Builder | 参数转换 | 未实现 | 实现转换逻辑 |
| interface | 保留 | 保留 | 无需修改 |
| 类型断言 | 保留 | 需正确处理 | 移除断言语法 |

### 2.3 实现策略

由于 ets2jsc 无法依赖 TypeScript 的 emit，因此需要：

1. **对于现代 JS 语法（对象字面量、NewExpression 等）**：
   - 修复 parse-ets.js 的 JSON 序列化逻辑
   - 确保 TypeScriptScriptParser 正确转换为字符串

2. **对于 ETS 特有装饰器（@Entry、@Builder）**：
   - 参考原始编译器的转换逻辑
   - 在 Java 中实现等效转换

---

## 三、迭代4技术实现方案

### 3.1 P0 级别需求实现方案

#### P0-OBJECT-LITERAL: 对象字面量表达式

**问题描述：**
- 对象字面量在函数参数中被错误转换为字符串
- 对象字面量属性值丢失

**示例问题：**
```
输入: convertKey({ data: keyData })
错误: convertKey({"kind":...})  // 输出为 JSON 对象
预期: convertKey({data: keyData})
```

**原始编译器处理方式：** 完全保留，由 TypeScript emit 自动处理

**ets2jsc 实现方案：**

##### 3.1.1.1 parse-ets.js 修改

**文件位置：** `ets2jsc/src/main/resources/typescript-parser/parse-ets.js`

**问题分析：** 当前 `convertAstToJson` 函数中对象字面量序列化不完整

**解决方案：** 确保 ObjectLiteralExpression 的属性完整序列化

**修改位置：** 第476-484行（ObjectLiteralExpression 处理）

```javascript
// 验证现有的 ObjectLiteralExpression 处理是否完整
case ts.SyntaxKind.ObjectLiteralExpression:
    result.properties = [];
    if (node.properties) {
        for (const prop of node.properties) {
            result.properties.push(convertAstToJson(prop));
        }
    }
    break;
```

**同时确保 PropertyAssignment 序列化正确：**

```javascript
case ts.SyntaxKind.PropertyAssignment:
    result.name = node.name ? convertAstToJson(node.name) : null;
    result.initializer = node.initializer ? convertAstToJson(node.initializer) : null;
    break;

case ts.SyntaxKind.ShorthandPropertyAssignment:
    result.name = node.name ? convertAstToJson(node.name) : null;
    result.objectAssignmentInitializer = node.objectAssignmentInitializer ? convertAstToJson(node.objectAssignmentInitializer) : null;
    break;

case ts.SyntaxKind SpreadAssignment:  // 如果支持展开
    result.expression = convertAstToJson(node.expression);
    break;
```

**kindMap 验证：** 确保 getSyntaxKindName 函数中包含

```javascript
[ts.SyntaxKind.ObjectLiteralExpression]: 'ObjectLiteralExpression',
[ts.SyntaxKind.PropertyAssignment]: 'PropertyAssignment',
[ts.SyntaxKind.ShorthandPropertyAssignment]: 'ShorthandPropertyAssignment',
[ts.SyntaxKind.SpreadAssignment]: 'SpreadAssignment',
```

##### 3.1.1.2 TypeScriptScriptParser.java 修改

**文件位置：** `ets2jsc/src/main/java/com/ets2jsc/parser/TypeScriptScriptParser.java`

**在 convertExpressionToString 方法中完善对象字面量处理：**

**现有代码位置：** 第659-674行

**验证并完善实现：**

```java
case "ObjectLiteralExpression": {
    JsonArray properties = exprJson.getAsJsonArray("properties");
    if (properties == null || properties.size() == 0) {
        return "{}";
    }

    StringBuilder sb = new StringBuilder();
    sb.append("{");

    for (int i = 0; i < properties.size(); i++) {
        if (i > 0) sb.append(", ");

        JsonObject prop = properties.get(i).getAsJsonObject();
        String kindName = prop.has("kindName") ? prop.get("kindName").getAsString() : "";

        if ("PropertyAssignment".equals(kindName)) {
            // 完整属性赋值: name: value
            JsonObject nameObj = prop.getAsJsonObject("name");
            String name = nameObj != null ? convertExpressionToString(nameObj) : "";
            JsonObject initObj = prop.getAsJsonObject("initializer");
            String value = initObj != null ? convertExpressionToString(initObj) : "";
            sb.append(name).append(": ").append(value);
        } else if ("ShorthandPropertyAssignment".equals(kindName)) {
            // 简写属性: name (等同于 name: name)
            JsonObject nameObj = prop.getAsJsonObject("name");
            String name = nameObj != null ? convertExpressionToString(nameObj) : "";
            sb.append(name);
        } else if ("SpreadAssignment".equals(kindName)) {
            // 展开属性: ...obj
            JsonObject expr = prop.getAsJsonObject("expression");
            String exprStr = expr != null ? convertExpressionToString(expr) : "";
            sb.append("...").append(exprStr);
        }
    }

    sb.append("}");
    return sb.toString();
}
```

**参考模式：** 参考第683-697行 `convertArrayLiteralToString` 方法的实现模式

---

#### P0-NEW-EXPRESSION: NewExpression 表达式

**问题描述：**
- `new Class()` 被输出为 JSON 对象 `{"kind":215,...}`
- 带属性访问的 NewExpression 如 `new util.TextEncoder()` 未正确处理
- 嵌套的 NewExpression 如 `new Promise((resolve) => {...})` 未正确处理

**示例问题：**
```
输入: new Uint8Array(16)
错误: {"kind":215,"kindName":"NewExpression",...}
预期: new Uint8Array(16)
```

**原始编译器处理方式：** 完全保留，使用 ts.factory.createNewExpression()

**ets2jc 实现方案：**

##### 3.1.2.1 parse-ets.js 修改

**问题分析：** NewExpression 的 JSON 序列化可能不完整

**修改位置：** 第390-396行（NewExpression 处理）

```javascript
// 验证现有的 NewExpression 处理是否完整
case ts.SyntaxKind.NewExpression:
    result.expression = convertAstToJson(node.expression);
    result.typeArguments = node.typeArguments ? node.typeArguments.map(t => convertAstToJson(t)) : [];
    result.arguments = node.arguments ? node.arguments.map(arg => convertAstToJson(arg)) : [];
    break;
```

**特别确保：** expression 字段对于 `new util.TextEncoder()` 这样的属性访问表达式被正确序列化

##### 3.1.2.2 TypeScriptScriptParser.java 修改

**文件位置：** `ets2jsc/src/main/java/com/ets2jsc/parser/TypeScriptScriptParser.java`

**在 convertExpressionToString 方法中添加/验证 NewExpression 处理：**

**位置：** 在第568-670行之间查找或添加

```java
case "NewExpression": {
    // 处理 new 表达式
    JsonObject exprObj = exprJson.getAsJsonObject("expression");
    String exprStr = exprObj != null ? convertExpressionToString(exprObj) : "";

    // 处理类型参数（在 JS 中忽略）
    JsonArray typeArgs = exprJson.getAsJsonArray("typeArguments");

    // 处理参数列表
    JsonArray args = exprJson.getAsJsonArray("arguments");
    StringBuilder argsStr = new StringBuilder();

    if (args != null && args.size() > 0) {
        argsStr.append("(");
        for (int i = 0; i < args.size(); i++) {
            if (i > 0) argsStr.append(", ");
            JsonObject arg = args.get(i).getAsJsonObject();
            String argStr = convertExpressionToString(arg);
            argsStr.append(argStr);
        }
        argsStr.append(")");
    } else {
        argsStr.append("()");
    }

    return "new " + exprStr + argsStr.toString();
}
```

**参考模式：** 参考第644-658行 CallExpression 的处理方式，NewExpression 结构类似

---

#### P0-TEMPLATE: 复杂模板字符串

**问题描述：**
- 简单模板字符串可能正常工作
- 复杂模板字符串（包含三元表达式、函数调用等）被输出为 JSON

**示例问题：**
```
输入: `${message}: ${typeof error === 'string' ? error : error.message}`
错误: {"kind":...}
预期: `${message}: ${typeof error === "string" ? error : error.message}`
```

**原始编译器处理方式：** 完全保留，作为 NoSubstitutionTemplateLiteral 或 TemplateExpression

**ets2jc 实现方案：**

##### 3.1.3.1 parse-ets.js 修改

**修改位置：** 第478行之后

```javascript
case ts.SyntaxKind.TemplateExpression:
    result.head = { text: node.head.text };
    result.templateSpans = [];
    for (const span of node.templateSpans) {
        result.templateSpans.push({
            expression: convertAstToJson(span.expression),
            literal: { text: span.literal.text }
        });
    }
    break;

case ts.SyntaxKind.NoSubstitutionTemplateLiteral:
    result.text = node.text;
    break;
```

**kindMap 添加：**

```javascript
[ts.SyntaxKind.TemplateExpression]: 'TemplateExpression',
[ts.SyntaxKind.NoSubstitutionTemplateLiteral]: 'NoSubstitutionTemplateLiteral',
```

##### 3.1.3.2 TypeScriptScriptParser.java 修改

**在 convertExpressionToString 方法中添加/完善：**

```java
case "TemplateExpression": {
    // 处理带插值的模板字符串: `hello ${name}`
    JsonObject head = exprJson.getAsJsonObject("head");
    String headText = head != null && head.has("text") ? head.get("text").getAsString() : "";

    JsonArray spans = exprJson.getAsJsonArray("templateSpans");

    StringBuilder sb = new StringBuilder();
    sb.append("`");

    // 添加头部文本
    sb.append(escapeTemplateLiteral(headText));

    if (spans != null) {
        for (JsonElement spanElem : spans) {
            JsonObject span = spanElem.getAsJsonObject();

            // 处理插值表达式
            JsonObject expr = span.getAsJsonObject("expression");
            String exprStr = expr != null ? convertExpressionToString(expr) : "";
            sb.append("${").append(exprStr).append("}");

            // 处理插值后的文本
            JsonObject literal = span.getAsJsonObject("literal");
            String litText = literal != null && literal.has("text") ? literal.get("text").getAsString() : "";
            sb.append(escapeTemplateLiteral(litText));
        }
    }

    sb.append("`");
    return sb.toString();
}

case "NoSubstitutionTemplateLiteral": {
    // 处理无插值的模板字符串: `hello world`
    String text = exprJson.has("text") ? exprJson.get("text").getAsString() : "";
    return "`" + escapeTemplateLiteral(text) + "`";
}
```

**新增辅助方法：**

```java
/**
 * 转义模板字符串中的特殊字符
 */
private String escapeTemplateLiteral(String str) {
    if (str == null) return "";
    // 转义反引号和 ${
    return str.replace("\\", "\\\\")
              .replace("`", "\\`")
              .replace("${", "\\${");
}
```

---

### 3.2 P1 级别需求实现方案

#### P1-ARROW: 箭头函数完整支持

**问题描述：**
- 箭头函数作为参数时可能被转换为字符串
- 箭头函数内部使用 await 需要正确处理
- 非异步箭头函数中使用 await，需要正确添加 async 关键字

**示例问题：**
```
输入: .onChange((value) => { this.inputText = value })
错误: 可能输出不正确
预期: .onChange((value) => { this.inputText = value })

输入: Button('加密').onClick(() => { await encrypt() })
错误: 语法错误
预期: Button("加密").onClick(async () => { await encrypt() })
```

**原始编译器处理方式：** 完全保留箭头函数语法

**ets2jc 实现方案：**

##### 3.2.1.1 parse-ets.js 修改

**验证 ArrowFunction 处理：** 第355-363行

```javascript
case ts.SyntaxKind.ArrowFunction:
    result.modifiers = node.modifiers ? node.modifiers.map(m => convertAstToJson(m)) : [];
    result.typeParameters = node.typeParameters ? node.typeParameters.map(t => convertAstToJson(t)) : [];
    result.parameters = node.parameters.map(p => convertAstToJson(p));
    result.type = node.type ? convertAstToJson(node.type) : null;
    result.equalsGreaterThanToken = node.equalsGreaterThanToken ? true : false;
    result.body = convertAstToJson(node.body);
    break;
```

**关键：** 确保 `modifiers` 字段正确输出，用于检测 `async` 关键字

##### 3.2.1.2 TypeScriptScriptParser.java 修改

**在 convertExpressionToString 方法中完善 ArrowFunction 处理：**

**现有代码位置：** 需要找到或添加 ArrowFunction 的处理

```java
case "ArrowFunction": {
    // 处理箭头函数
    // 1. 检查是否有 async 修饰符
    boolean isAsync = false;
    JsonArray modifiers = exprJson.getAsJsonArray("modifiers");
    if (modifiers != null) {
        for (JsonElement modElem : modifiers) {
            JsonObject mod = modElem.getAsJsonObject();
            String modKind = mod.has("kindName") ? mod.get("kindName").getAsString() : "";
            if ("AsyncKeyword".equals(modKind)) {
                isAsync = true;
                break;
            }
        }
    }

    // 2. 检查函数体是否包含 await 表达式
    JsonObject body = exprJson.getAsJsonObject("body");
    boolean containsAwait = containsAwaitExpression(body);

    // 如果包含 await 但不是 async，需要添加 async
    if (containsAwait && !isAsync) {
        isAsync = true;
    }

    StringBuilder sb = new StringBuilder();

    // 添加 async 关键字
    if (isAsync) {
        sb.append("async ");
    }

    // 添加参数列表
    sb.append("(");
    JsonArray params = exprJson.getAsJsonArray("parameters");
    if (params != null && params.size() > 0) {
        for (int i = 0; i < params.size(); i++) {
            if (i > 0) sb.append(", ");
            JsonObject param = params.get(i).getAsJsonObject();
            String paramStr = convertParameterToString(param);
            sb.append(paramStr);
        }
    }
    sb.append(")");

    // 添加箭头和函数体
    sb.append(" => ");

    if (body != null) {
        String kindName = body.has("kindName") ? body.get("kindName").getAsString() : "";
        if ("Block".equals(kindName)) {
            // 块状函数体
            sb.append(convertBlockToString(body));
        } else {
            // 表达式函数体
            sb.append(convertExpressionToString(body));
        }
    }

    return sb.toString();
}
```

**新增辅助方法：**

```java
/**
 * 检查 AST 节点是否包含 await 表达式
 */
private boolean containsAwaitExpression(JsonObject node) {
    if (node == null) return false;

    String kindName = node.has("kindName") ? node.get("kindName").getAsString() : "";

    // 如果是 AwaitExpression，直接返回 true
    if ("AwaitExpression".equals(kindName)) {
        return true;
    }

    // 递归检查子节点
    for (String key : node.keySet()) {
        if ("kind".equals(key) || "kindName".equals(key)) continue;

        JsonElement elem = node.get(key);
        if (elem.isJsonObject()) {
            if (containsAwaitExpression(elem.getAsJsonObject())) {
                return true;
            }
        } else if (elem.isJsonArray()) {
            for (JsonElement item : elem.getAsJsonArray()) {
                if (item.isJsonObject() && containsAwaitExpression(item.getAsJsonObject())) {
                    return true;
                }
            }
        }
    }

    return false;
}

/**
 * 将参数转换为字符串
 */
private String convertParameterToString(JsonObject param) {
    JsonObject name = param.getAsJsonObject("name");
    String nameStr = name != null ? convertExpressionToString(name) : "";

    // 可选参数
    boolean hasQuestionToken = param.has("questionToken") && param.get("questionToken").getAsBoolean();
    if (hasQuestionToken) {
        nameStr += "?";
    }

    // 默认值
    JsonObject initializer = param.getAsJsonObject("initializer");
    if (initializer != null) {
        String initStr = convertExpressionToString(initializer);
        nameStr += " = " + initStr;
    }

    return nameStr;
}

/**
 * 将块转换为字符串
 */
private String convertBlockToString(JsonObject block) {
    JsonArray statements = block.getAsJsonArray("statements");
    StringBuilder sb = new StringBuilder();
    sb.append("{\n");

    if (statements != null) {
        for (JsonElement stmtElem : statements) {
            JsonObject stmt = stmtElem.getAsJsonObject();
            AstNode stmtNode = convertJsonNode(stmt);
            if (stmtNode != null) {
                sb.append("  ").append(stmtNode.toCodeString()).append("\n");
            }
        }
    }

    sb.append("}");
    return sb.toString();
}
```

---

#### P1-ENTRY: @Entry 装饰器

**问题描述：**
- 使用 @Entry 装饰器的 struct 需要导出
- 当前编译结果未导出

**示例问题：**
```
输入:
@Entry
@Component
export struct ImagePage {
  build() { ... }
}

错误: class ImagePage extends View { ... }  // 缺少 export
预期: export class ImagePage extends View { ... }
```

**原始编译器处理方式：**
1. 验证 @Entry 必须与 @Component 一起使用
2. 验证 @Entry 组件必须导出
3. 如果验证通过，保持导出

**来源：** `compiler/src/check_ui_syntax.ts`

**ets2jc 实现方案：**

##### 3.2.2.1 parse-ets.js 修改

**在预处理阶段提取 @Entry 装饰器信息：**

**修改位置：** 在 struct 预处理逻辑中（第50-100行区域）

```javascript
// 在 extractDecorators 函数中添加 @Entry 检测
function extractDecorators(sourceCode) {
    const decorators = [];

    // 检测 @Entry 装饰器
    const entryPattern = /@Entry\s*(?:\([^)]*\))?\s*/g;
    // ... 现有逻辑

    return decorators;
}
```

##### 3.2.2.2 ComponentTransformer.java 修改

**文件位置：** `ets2jc/src/main/java/com/ets2jsc/transformer/ComponentTransformer.java`

**在转换 struct 时检查 @Entry 装饰器：**

```java
// 在 transformComponent 方法中添加
private ClassDeclaration transformComponent(JsonObject structJson) {
    // ... 现有代码

    // 检查是否有 @Entry 装饰器
    boolean hasEntryDecorator = hasDecorator(structJson, "Entry");

    // 如果有 @Entry，确保导出
    boolean isExported = structJson.has("modifiers") &&
                         hasExportModifier(structJson.getAsJsonArray("modifiers"));

    if (hasEntryDecorator && !isExported) {
        // @Entry 组件必须导出，自动添加
        classDeclaration.setExported(true);
    } else if (isExported) {
        classDeclaration.setExported(true);
    }

    return classDeclaration;
}

/**
 * 检查是否有指定装饰器
 */
private boolean hasDecorator(JsonObject node, String decoratorName) {
    if (!node.has("decorators")) return false;

    JsonArray decorators = node.getAsJsonArray("decorators");
    for (JsonElement decorElem : decorators) {
        JsonObject decor = decorElem.getAsJsonObject();
        JsonObject expr = decor.getAsJsonObject("expression");
        if (expr != null) {
            String name = expr.has("text") ? expr.get("text").getAsString() : "";
            if (decoratorName.equals(name)) {
                return true;
            }
        }
    }
    return false;
}

/**
 * 检查是否有 export 修饰符
 */
private boolean hasExportModifier(JsonArray modifiers) {
    if (modifiers == null) return false;

    for (JsonElement modElem : modifiers) {
        JsonObject mod = modElem.getAsJsonObject();
        String kindName = mod.has("kindName") ? mod.get("kindName").getAsString() : "";
        if ("ExportKeyword".equals(kindName)) {
            return true;
        }
    }
    return false;
}
```

---

#### P1-BUILDER: @Builder 方法

**问题描述：**
- @Builder 方法被当作普通方法处理
- 缺少 @Builder 方法的特殊包装逻辑

**示例问题：**
```
输入:
@Component
export struct Index {
  @Builder
  TabBar(index: number, icon: string, label: string) {
    Column() {
      Text(icon)
      Text(label)
    }
  }
}

错误: 作为普通方法处理
预期: 转换为 Builder 函数格式
```

**原始编译器处理方式：**
1. 识别 @Builder 装饰器的方法
2. 添加 `__builder__: BuilderParam = undefined` 参数
3. 转换方法体中的组件调用
4. 在调用点创建 BuilderParam 对象

**来源：** `compiler/src/process_interop_builder.ts`

**ets2jc 实现方案：**

##### 3.2.3.1 parse-ets.js 修改

**在 MethodDeclaration 处理中提取 @Builder 信息：**

**修改位置：** 第334-349行（MethodDeclaration）

```javascript
case ts.SyntaxKind.MethodDeclaration:
    result.modifiers = node.modifiers ? node.modifiers.map(m => convertAstToJson(m)) : [];
    // ... 现有代码
    result.decorators = node.decorators ? node.decorators.map(d => convertAstToJson(d)) : [];
    // 添加标志表示是否有 @Builder 装饰器
    if (node.decorators) {
        const hasBuilder = node.decorators.some(d => d.expression && d.expression.text === 'Builder');
        result.hasBuilderDecorator = hasBuilder;
    }
    break;
```

##### 3.2.3.2 TypeScriptScriptParser.java 修改

**创建新的转换方法处理 @Builder 方法：**

```java
/**
 * 转换 @Builder 装饰的方法
 */
private MethodDeclaration convertBuilderMethod(JsonObject methodJson, ClassDeclaration classDecl) {
    String methodName = getMethodName(methodJson);

    // 获取原有参数列表
    JsonArray params = methodJson.getAsJsonArray("parameters");
    List<Parameter> builderParams = new ArrayList<>();

    // 添加 __builder__ 参数作为第一个参数
    Parameter builderParam = new Parameter();
    builderParam.setName("__builder__");
    builderParam.setType("BuilderParam");
    builderParam.setDefaultValue("undefined");
    builderParams.add(builderParam);

    // 添加原有参数（移除类型注解）
    if (params != null) {
        for (JsonElement paramElem : params) {
            JsonObject param = paramElem.getAsJsonObject();
            Parameter p = convertParameter(param);
            builderParams.add(p);
        }
    }

    // 创建方法声明
    MethodDeclaration methodDecl = new MethodDeclaration();
    methodDecl.setName(methodName);
    methodDecl.setParameters(builderParams);
    methodDecl.setIsBuilderMethod(true);

    // 转换方法体
    JsonObject body = methodJson.getAsJsonObject("body");
    if (body != null) {
        Block methodBody = convertBuilderMethodBody(body);
        methodDecl.setBody(methodBody);
    }

    return methodDecl;
}

/**
 * 转换 @Builder 方法体（特殊处理组件调用）
 */
private Block convertBuilderMethodBody(JsonObject bodyJson) {
    Block block = new Block();
    List<Statement> statements = new ArrayList<>();

    JsonArray stmts = bodyJson.getAsJsonArray("statements");
    if (stmts != null) {
        for (JsonElement stmtElem : stmts) {
            JsonObject stmt = stmtElem.getAsJsonObject();
            Statement converted = convertBuilderStatement(stmt);
            statements.add(converted);
        }
    }

    block.setStatements(statements);
    return block;
}
```

---

#### P1-TYPE-ANNOT: 类型注解处理

**问题描述：**
- 变量声明的类型注解需要移除
- 函数参数的类型注解已正确处理为注释

**示例问题：**
```
输入: const files: FileInfo[] = []
错误: const files: FileInfo = []  // 类型注解未完全移除
预期: const files = []
```

**原始编译器处理方式：**
- TypeScript 编译器自动移除类型注解
- 变量声明的类型注解在 emit 时完全移除

**ets2jc 实现方案：**

##### 3.2.4.1 TypeScriptScriptParser.java 修改

**在 VariableStatement 转换中确保类型注解被忽略：**

**验证现有代码：** VariableStatement 相关处理

```java
// 在 convertVariableDeclaration 方法中
private VariableDeclaration convertVariableDeclaration(JsonObject json) {
    String name = json.get("name").getAsString();

    // 跳过类型注解，直接获取初始值
    JsonObject initializer = json.getAsJsonObject("initializer");
    Expression initExpr = null;
    if (initializer != null) {
        String initStr = convertExpressionToString(initializer);
        initExpr = new Expression(initStr);
    }

    VariableDeclaration varDecl = new VariableDeclaration();
    varDecl.setName(name);
    varDecl.setInitializer(initExpr);
    // 不设置 type 字段，确保类型注解被移除

    return varDecl;
}
```

---

#### P1-OCTAL: 八进制字面量

**问题描述：**
- 八进制字面量语法 `0o1` 需要转换为十进制

**示例问题：**
```
输入: const file = fs.openSync(fileUri, 0o1)
预期输出: const file = fs.openSync(fileUri, 1)
```

**原始编译器处理方式：**
- 八进制字面量在编译时被计算为实际数值
- TypeScript emit 输出计算后的十进制值

**ets2jc 实现方案：**

##### 3.2.5.1 parse-ets.js 修改

**在 NumericLiteral 处理中添加八进制检测：**

**修改位置：** 第448-452行

```javascript
case ts.SyntaxKind.NumericLiteral:
    result.text = node.text;
    // 添加实际值
    result.value = node.numericLiteralValue;
    break;
```

##### 3.2.5.2 TypeScriptScriptParser.java 修改

**在处理数字字面量时使用计算后的值：**

```java
case "NumericLiteral": {
    // 优先使用计算后的值
    if (exprJson.has("value")) {
        Number value = exprJson.get("value").getAsNumber();
        return String.valueOf(value.intValue());
    }
    // 如果没有 value，使用 text（可能包含 0o 前缀）
    String text = exprJson.has("text") ? exprJson.get("text").getAsString() : "0";
    // 手动转换八进制
    if (text.startsWith("0o") || text.startsWith("0O")) {
        String octalStr = text.substring(2);
        try {
            int decimalValue = Integer.parseInt(octalStr, 8);
            return String.valueOf(decimalValue);
        } catch (NumberFormatException e) {
            return text; // 保持原样
        }
    }
    return text;
}
```

---

### 3.3 P2 级别需求实现方案

#### P2-DYNAMIC-IMPORT: 动态导入

**问题描述：**
- `await import()` 被输出为 `await {"kind":102,"kindName":"ImportKeyword"}(...)`

**示例问题：**
```
输入: const nfcModule = await import('@ohos.nfc')
错误: await {"kind":...}(...)
预期: await import("@ohos.nfc")
```

**原始编译器处理方式：**
- 动态导入是标准 ES2020 语法
- 通过 ts.visitEachChild 自动保留

**ets2jc 实现方案：**

##### 3.3.1.1 parse-ets.js 修改

**添加 ImportExpression 处理：**

**修改位置：** 第396行之后

```javascript
case ts.SyntaxKind.ImportExpression:
    result.expression = convertAstToJson(node.expression);
    result.arguments = node.arguments ? node.arguments.map(arg => convertAstToJson(arg)) : [];
    break;
```

**kindMap 添加：**

```javascript
[ts.SyntaxKind.ImportExpression]: 'ImportExpression',
```

##### 3.3.1.2 TypeScriptScriptParser.java 修改

**在 convertExpressionToString 方法中添加：**

```java
case "ImportExpression": {
    // 处理动态导入: await import('module')
    JsonObject arg = exprJson.getAsJsonObject("argument");
    String modulePath = arg != null ? convertExpressionToString(arg) : "";

    // import() 函数调用
    return "import(" + modulePath + ")";
}
```

---

#### P2-INTERFACE: interface 接口声明

**问题描述：**
- interface 声明被忽略，未生成任何代码

**原始编译器处理方式：**
- interface 是 TypeScript 特有语法
- 编译为 JS 时，interface 完全移除（不生成任何代码）

**ets2jc 实现方案：**

##### 3.3.2.1 TypeScriptScriptParser.java 修改

**在 convertJsonNode 方法中添加 InterfaceDeclaration 处理：**

```java
case "InterfaceDeclaration":
    // interface 声明在 JS 中不生成任何代码
    return null;  // 返回 null 表示不生成代码
```

---

#### P2-TYPE-ASSERTION: 类型断言

**问题描述：**
- `as` 类型断言语法需要移除

**示例问题：**
```
输入: Logger.error('操作失败', error as BusinessError)
预期: Logger.error("操作失败", error)
```

**原始编译器处理方式：**
- 类型断言在运行时没有意义
- TypeScript emit 完全移除断言语法，只保留表达式

**ets2jc 实现方案：**

##### 3.3.3.1 parse-ets.js 修改

**添加 AsExpression 和 TypeAssertion 处理：**

**修改位置：** 第382行之后

```javascript
case ts.SyntaxKind.AsExpression:
case ts.SyntaxKind.TypeAssertion:
    result.expression = convertAstToJson(node.expression);
    // type 字段可以用于调试，但在代码生成时忽略
    break;
```

**kindMap 添加：**

```javascript
[ts.SyntaxKind.AsExpression]: 'AsExpression',
[ts.SyntaxKind.TypeAssertion]: 'TypeAssertion',
```

##### 3.3.3.2 TypeScriptScriptParser.java 修改

**在 convertExpressionToString 方法中添加：**

```java
case "AsExpression":
case "TypeAssertion": {
    // 类型断言在 JS 中不需要，直接输出表达式
    JsonObject expr = exprJson.getAsJsonObject("expression");
    return expr != null ? convertExpressionToString(expr) : "";
}
```

---

#### P2-FOR-LOOPS: for-of 和 for 循环

**问题描述：**
- 循环语句在迭代3中已处理，这里验证实现正确性

**原始编译器处理方式：** 完全保留

**ets2jc 实现方案：**

参考迭代3技术方案文档中 P0-LOOP 部分的实现，验证：

1. ForOfStatement 已正确实现
2. ForStatement 已正确实现
3. 循环体正确转换为代码字符串

---

## 四、实现优先级与计划

### 4.1 实现顺序

基于原始编译器的"最小干预"原则和问题的紧急程度，建议按以下顺序实现：

**第1周：P0 核心问题修复（JSON 序列化）**
1. P0-OBJECT-LITERAL: 对象字面量表达式（修复属性序列化）
2. P0-NEW-EXPRESSION: NewExpression 表达式（修复完整序列化）
3. P0-TEMPLATE: 复杂模板字符串（修复 templateSpans 序列化）

**第2周：P1 重要功能（装饰器和类型）**
4. P1-ARROW: 箭头函数完整支持（async/await 检测）
5. P1-ENTRY: @Entry 装饰器（导出处理）
6. P1-TYPE-ANNOT: 类型注解处理（变量声明类型移除）
7. P1-OCTAL: 八进制字面量（转换为十进制）

**第3周：P1 Builder 方法**
8. P1-BUILDER: @Builder 方法（参数和转换逻辑）

**第4周：P2 增强功能**
9. P2-DYNAMIC-IMPORT: 动态导入
10. P2-INTERFACE: interface 接口声明
11. P2-TYPE-ASSERTION: 类型断言

**第5周：测试和优化**
12. 完整的集成测试
13. 性能优化
14. 文档更新

### 4.2 测试策略

**单元测试：** 每个语法特性对应一个测试用例

**集成测试：** 使用 harmony-utils 工具库作为完整测试案例

**验收标准：**
- 所有 harmony-utils 项目文件编译通过
- 生成的 JS 文件通过 `node -c` 语法检查
- 生成的 JS 文件通过 `es2abc` 字节码编译

---

## 五、关键原则与注意事项

### 5.1 必须遵循的原则

1. **复用原始编译器方案**
   - 对于现代 JS 语法：确保输出与 TypeScript emit 一致
   - 对于 ETS 特有装饰器：参考原始编译器的转换逻辑

2. **不改变架构**
   - 所有修改在现有三层架构内进行
   - 不引入新的处理层级或文件

3. **保持代码一致性**
   - 新增代码风格与现有代码保持一致
   - 遵循现有的命名和结构约定

4. **渐进式实现**
   - 按优先级逐步实现
   - 每个功能独立测试验证

### 5.2 避免的陷阱

1. **避免过度转换**：现代 JS 语法应该保留，不需要"聪明"的转换
2. **避免破坏现有功能**：新增功能不应影响已有功能的正确性
3. **避免性能回退**：确保新增语法处理不影响编译性能
4. **避免重复实现**：检查现有代码，可能已有部分实现

### 5.3 与迭代3的关系

迭代4的实现应该：
1. 复用迭代3中已实现的循环语句处理
2. 复用迭代3中已实现的表达式处理框架
3. 重点关注对象、new 表达式、模板字符串的序列化问题
4. 新增装饰器相关转换逻辑

---

## 六、总结

本技术实现方案基于对原始编译器（`developtools_ace_ets2bundle`）的深入分析，针对迭代4需求采用以下策略：

1. **现代 JavaScript 语法**：修复 JSON 序列化和字符串转换，确保与 TypeScript emit 一致
2. **ETS 特有装饰器**：参考原始编译器的转换逻辑，实现 @Entry 和 @Builder 的转换
3. **架构一致性**：在现有三层架构内完成所有实现

所有实现方案都引用了具体的文件位置、行号和现有代码模式，确保开发人员可以准确、高效地完成实现。

---

**文档版本：** v1.0
**编写日期：** 2026-01-30
**编写人：** Claude AI Assistant
**文档状态：** 基于原始编译器实现方案创建
