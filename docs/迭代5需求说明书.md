# ETS 编译器迭代5需求说明书

## 文档信息

| 项目 | 内容 |
|------|------|
| 文档版本 | v1.0 |
| 创建日期 | 2026-01-31 |
| 项目名称 | ets2jsc 编译器 |
| 基准实现 | developtools_ace_ets2bundle |
| 目标 | 完成之前迭代中未实现的功能需求 |

---

## 一、概述

### 1.1 已完成功能总结

经过迭代2-4的开发，以下功能已完成：

**迭代2已完成：**
- ✅ UI 组件 create/pop 转换
- ✅ Import/Export 语句处理
- ✅ 类型声明处理
- ✅ 链式调用拆分
- ✅ ForEach 转换
- ✅ If 条件渲染转换
- ✅ @Prop 装饰器
- ✅ @Link 装饰器
- ✅ @Provide/@Consume 装饰器
- ✅ 基础表达式支持

**迭代3已完成：**
- ✅ 字面量表达式转换
- ✅ 循环语句转换 (for-of, for-in, while, do-while, for)
- ✅ 特殊表达式转换 (一元运算、类型断言、await、typeof)
- ✅ 数组/对象访问表达式
- ✅ Switch 语句
- ✅ 异常处理语句 (try-catch-finally)
- ✅ 展开语法
- ✅ 模板字符串
- ✅ 可选链运算符

**迭代4已完成：**
- ✅ 对象字面量表达式
- ✅ NewExpression 表达式
- ✅ 箭头函数完整支持（含 async/await 自动检测）
- ✅ 类型注解处理
- ✅ 八进制字面量转换
- ✅ 动态导入
- ✅ interface 声明过滤
- ✅ 类型断言移除

### 1.2 迭代5目标

本迭代的目标是完成之前迭代中标记为**缺失**的功能需求，包括：
1. @Builder 装饰器方法
2. @Entry 装饰器验证与导出
3. 资源引用处理 ($r(), $rawfile())
4. 跳转语句 (break, continue)
5. JSDoc 注释保留
6. 泛型语法处理
7. for 循环完整支持
8. async 方法转换
9. 属性链式调用主体绑定
10. 状态属性初始化

---

## 二、核心功能需求 (P0)

### 需求 #1: @Builder 装饰器方法

**优先级：** P0

**描述：** 支持 @Builder 装饰器的方法转换，将 @Builder 方法转换为 Builder 函数格式。

**输入示例：**
```typescript
@Component
struct Index {
  @Builder
  TabBar(index: number, icon: string, label: string) {
    Column() {
      Text(icon)
      Text(label)
    }
  }

  build() {
    TabBar(0, "home", "首页")
  }
}
```

**预期输出：**
```javascript
export class Index extends View {
  TabBar(__builder__, index, icon, label) {
    Column.create();
    Text.create(icon);
    Text.pop();
    Text.create(label);
    Text.pop();
    Column.pop();
  }

  render() {
    const __builder__ = new BuilderParam();
    this.TabBar(__builder__, 0, "home", "首页");
    __builder__.build();
  }
}
```

**详细需求：**
1. **参数转换**：@Builder 方法的第一个参数应自动添加 `__builder__: BuilderParam = undefined`
2. **函数体转换**：方法体内的组件调用需要转换为 create/pop 模式
3. **调用点转换**：调用 @Builder 方法时需要：
   - 创建 BuilderParam 对象
   - 将对象作为第一个参数传递
   - 调用 build() 方法

**验收标准：**
- @Builder 方法正确添加 __builder__ 参数
- 方法体内组件正确转换为 create/pop 模式
- 调用点正确包装 BuilderParam 逻辑
- 生成的 JavaScript 代码可正常运行

---

### 需求 #2: @Entry 装饰器验证与导出

**优先级：** P0

**描述：** @Entry 装饰器标记的组件必须导出，且需要验证 @Entry 只能与 @Component 一起使用。

**输入示例：**
```typescript
@Entry
@Component
struct ImagePage {
  build() {
    Text("Hello")
  }
}
```

**预期输出：**
```javascript
export class ImagePage extends View {
  render() {
    Text.create("Hello");
    Text.pop();
  }
}
```

**详细需求：**
1. **验证规则**：
   - @Entry 只能用于 @Component 装饰的 struct
   - @Entry 组件必须导出（自动添加 export 关键字）
2. **导出处理**：
   - 如果 struct 有 @Entry 但无 export，自动添加 export
   - 如果 struct 已有 export，保持 export

**错误情况处理：**
- @Entry 用于非 @Component struct 时报错
- 编译失败并提示用户

**验收标准：**
- @Entry 组件正确导出
- 验证规则正确实施
- 错误情况能正确报错并提示

---

### 需求 #3: 资源引用处理

**优先级：** P0

**描述：** 支持 $r() 和 $rawfile() 资源引用的转换。

**输入示例：**
```typescript
Text($r('app.string.name'))
Image($rawfile('icon.png'))
```

**预期输出：**
```javascript
Text.create(__getResourceId__(10003, undefined, "app_module", "name"));
Image.create(__getRawFileId__("icon.png"));
```

**详细需求：**

1. **$r() 资源引用**：
   - 解析资源路径格式：`'app.type.name'`
   - 识别资源类型并映射为数字 ID
   - 生成 `__getResourceId__(type, bundle, module, name)` 调用

2. **资源类型映射表**：
   | 类型 | ID |
   |------|-----|
   | color | 10001 |
   | float | 10002 |
   | string | 10003 |
   | plural | 10004 |
   | boolean | 10005 |
   | intarray | 10006 |
   | integer | 10007 |
   | pattern | 10008 |
   | strarray | 10009 |
   | media | 10010 |
   | font | 10011 |
   | profile | 10012 |

3. **$rawfile() 资源引用**：
   - 直接传递文件名
   - 生成 `__getRawFileId__(filename)` 调用

**验收标准：**
- $r() 正确转换为 __getResourceId__ 调用
- 资源类型正确映射为数字 ID
- $rawfile() 正确转换为 __getRawFileId__ 调用
- 支持嵌套在表达式中的资源引用

---

## 三、重要功能需求 (P1)

### 需求 #4: 跳转语句 (break, continue)

**优先级：** P1

**描述：** 支持 break 和 continue 语句的正确转换。

**输入示例：**
```typescript
for (let i = 0; i < 10; i++) {
  if (i === 5) {
    break;
  }
  if (i % 2 === 0) {
    continue;
  }
  console.log(i);
}
```

**预期输出：**
```javascript
for (let i = 0; i < 10; i++) {
  if (i === 5) {
    break;
  }
  if (i % 2 === 0) {
    continue;
  }
  console.log(i);
}
```

**详细需求：**
1. **break 语句**：
   - 支持不带标签的 break
   - 支持带标签的 break

2. **continue 语句**：
   - 支持不带标签的 continue
   - 支持带标签的 continue

**验收标准：**
- break/continue 语句正确输出
- 标签正确保留

---

### 需求 #5: JSDoc 注释保留

**优先级：** P1

**描述：** 保留源代码中的 JSDoc 注释，确保 API 文档不会丢失。

**输入示例：**
```typescript
/**
 * 计算两个数的和
 * @param {number} a - 第一个数
 * @param {number} b - 第二个数
 * @returns {number} 两数之和
 */
function add(a: number, b: number): number {
  return a + b;
}
```

**预期输出：**
```javascript
/**
 * 计算两个数的和
 * @param {number} a - 第一个数
 * @param {number} b - 第二个数
 * @returns {number} 两数之和
 */
function add(a, b) {
  return a + b;
}
```

**详细需求：**
1. **注释位置**：
   - 函数/方法前的 JSDoc
   - 类声明前的 JSDoc
   - 属性声明前的 JSDoc

2. **注释内容**：
   - 完整保留注释文本
   - 保留所有标签 (@param, @returns, @type 等)

**验收标准：**
- JSDoc 注释正确保留在生成的代码中
- 注释位置正确
- 注释内容完整

---

### 需求 #6: 泛型语法处理

**优先级：** P1

**描述：** 处理 TypeScript 泛型语法，在 JavaScript 中正确移除或转换。

**输入示例：**
```typescript
function identity<T>(arg: T): T {
  return arg;
}

class Container<T> {
  private value: T;
  constructor(value: T) {
    this.value = value;
  }
}
```

**预期输出：**
```javascript
function identity(arg) {
  return arg;
}

class Container {
  constructor(value) {
    this.value = value;
  }
}
```

**详细需求：**
1. **泛型函数**：
   - 移除泛型参数 `<T>`
   - 移除参数和返回值的类型注解

2. **泛型类**：
   - 移除类名后的泛型参数 `<T>`
   - 移除成员的类型注解

3. **泛型约束**：
   - 移除 `extends` 约束

**验收标准：**
- 泛型语法完全移除
- 运行时逻辑保持不变

---

### 需求 #7: for 循环完整支持

**优先级：** P1

**描述：** 完整支持 C 风格的 for 循环语句。

**输入示例：**
```typescript
for (let i = 0; i < 10; i++) {
  console.log(i);
}

for (let i = 0, j = 0; i < 10 && j < 5; i++, j++) {
  console.log(i, j);
}
```

**预期输出：**
```javascript
for (let i = 0; i < 10; i++) {
  console.log(i);
}

for (let i = 0, j = 0; i < 10 && j < 5; i++, j++) {
  console.log(i, j);
}
```

**详细需求：**
1. **完整语法支持**：
   - 初始化表达式（支持多个变量）
   - 条件表达式
   - 增量表达式（支持多个表达式）

2. **省略情况**：
   - 可省略初始化：`for (; i < 10; i++)`
   - 可省略条件：`for (let i = 0; ; i++)`
   - 可省略增量：`for (let i = 0; i < 10;)`

**验收标准：**
- for 循环语法完整保留
- 多变量情况正确处理
- 省略情况正确处理

---

### 需求 #8: async 方法转换

**优先级：** P1

**描述：** 支持类中的 async 方法转换。

**输入示例：**
```typescript
class MyClass {
  async fetchData(): Promise<void> {
    const data = await this.fetch();
    console.log(data);
  }
}
```

**预期输出：**
```javascript
class MyClass {
  async fetchData() {
    const data = await this.fetch();
    console.log(data);
  }
}
```

**详细需求：**
1. **async 关键字保留**：
   - 方法声明中的 async 关键字
   - 方法签名中的 Promise 类型注解移除

2. **await 表达式**：
   - await 关键字保留
   - await 的操作数正确转换

**验收标准：**
- async 关键字正确保留
- Promise 类型注解移除
- await 表达式正确处理

---

### 需求 #9: 属性链式调用主体绑定

**优先级：** P1

**描述：** 处理属性链式调用时的 `this` 绑定问题。

**输入示例：**
```typescript
class MyClass {
  private count: number = 0;

  increment() {
    this.count++;
  }

  process() {
    this.increment().increment().increment();
  }
}
```

**预期输出：**
```javascript
class MyClass {
  count__ = 0;

  get count() {
    return this.count__.get();
  }

  set count(newValue) {
    this.count__.set(newValue);
  }

  increment() {
    this.count++;
  }

  process() {
    this.increment();
    this.increment();
    this.increment();
  }
}
```

**详细需求：**
1. **链式调用检测**：识别方法调用的链式结构
2. **this 绑定处理**：确保每个方法调用都正确绑定到正确的 this

**注：** 此需求涉及运行时行为，需要根据 @State/@Prop 等装饰器的实现具体分析。

**验收标准：**
- 链式调用正确展开
- this 绑定正确处理

---

### 需求 #10: 状态属性初始化

**优先级：** P1

**描述：** 正确处理 @State/@Prop/@Link 装饰器属性的初始化逻辑。

**输入示例：**
```typescript
@Component
struct MyComponent {
  @State count: number = 0;
  @Prop title: string = "Hello";
  @Link value: number;

  build() {
    Text(`${this.title}: ${this.count}`)
  }
}
```

**预期输出：**
```javascript
export class MyComponent extends View {
  count__: ObservedPropertySimple<number>;
  title__: SynchedPropertySimpleOneWay<string>;
  value__: SynchedPropertySimpleTwoWay<number>;

  get count() {
    return this.count__.get();
  }

  set count(newValue) {
    this.count__.set(newValue);
  }

  get title() {
    return this.title__.get();
  }

  set title(newValue) {
    this.title__.set(newValue);
  }

  get value() {
    return this.value__.get();
  }

  set value(newValue) {
    this.value__.set(newValue);
  }

  constructor() {
    super();
    this.count__ = new ObservedPropertySimple(0, this);
    this.title__ = this.createProp("title", () => this.title);
    this.value__ = this.createLink("value", () => this.value);
  }

  render() {
    Text.create(`${this.title}: ${this.count}`);
    Text.pop();
  }
}
```

**详细需求：**
1. **@State 初始化**：
   - 私有属性名添加 `__` 后缀
   - 类型为 `ObservedPropertySimple<T>`
   - 构造函数中使用 `new ObservedPropertySimple(initialValue, this)` 初始化

2. **@Prop 初始化**：
   - 私有属性名添加 `__` 后缀
   - 类型为 `SynchedPropertySimpleOneWay<T>`
   - 构造函数中使用 `this.createProp(name, getter)` 初始化

3. **@Link 初始化**：
   - 私有属性名添加 `__` 后缀
   - 类型为 `SynchedPropertySimpleTwoWay<T>`
   - 构造函数中使用 `this.createLink(name, getter)` 初始化

**验收标准：**
- 私有属性正确创建
- getter/setter 正确生成
- 构造函数初始化逻辑正确

---

## 四、增强功能需求 (P2)

### 需求 #11: 可选链和空值合并完整支持

**优先级：** P2

**描述：** 确保可选链 `?.` 和空值合并 `??` 运算符正确输出。

**输入示例：**
```typescript
const name = user?.profile?.name;
const count = items ?? 0;
```

**预期输出：**
```javascript
const name = user?.profile?.name;
const count = items ?? 0;
```

**详细需求：**
1. **可选链**：
   - 属性访问可选链：`obj?.prop`
   - 方法调用可选链：`obj.method?.()`
   - 数组访问可选链：`arr?.[index]`

2. **空值合并**：
   - 基本用法：`a ?? b`
   - 结合其他运算符

**验收标准：**
- 可选链正确保留
- 空值合并正确保留

---

### 需求 #12: 解构赋值支持

**优先级：** P2

**描述：** 支持对象和数组解构赋值语法。

**输入示例：**
```typescript
const { name, age } = person;
const [first, second] = array;
const { name: n, age: a } = person;
```

**预期输出：**
```javascript
const { name, age } = person;
const [first, second] = array;
const { name: n, age: a } = person;
```

**详细需求：**
1. **对象解构**：
   - 基本解构：`const { a, b } = obj`
   - 重命名解构：`const { a: x, b: y } = obj`
   - 默认值：`const { a = 1 } = obj`

2. **数组解构**：
   - 基本解构：`const [a, b] = arr`
   - 跳过元素：`const [a, , b] = arr`
   - 默认值：`const [a = 1] = arr`

**验收标准：**
- 解构语法正确保留
- 重命名和默认值正确处理

---

### 需求 #13: 生成器函数支持

**优先级：** P2

**描述：** 支持 function* 生成器函数语法。

**输入示例：**
```typescript
function* generateNumbers() {
  yield 1;
  yield 2;
  yield 3;
}
```

**预期输出：**
```javascript
function* generateNumbers() {
  yield 1;
  yield 2;
  yield 3;
}
```

**详细需求：**
1. **生成器函数**：
   - `function*` 关键字保留
   - `yield` 表达式保留
   - `yield*` 表达式保留

**验收标准：**
- 生成器函数语法正确保留

---

## 五、验收标准总览

### 5.1 编译正确性

- [ ] 所有需求用例的 ETS 代码能正确编译为 JavaScript
- [ ] 生成的 JavaScript 代码语法正确
- [ ] 生成的代码通过 `node -c` 语法检查

### 5.2 运行时正确性

- [ ] 生成的 JavaScript 代码运行时行为与 ETS 源码一致
- [ ] @Builder 方法调用正确
- [ ] 资源引用正确解析
- [ ] 状态属性初始化正确

### 5.3 代码质量

- [ ] 生成的代码格式规范
- [ ] 生成的代码可读性强
- [ ] JSDoc 注释完整保留

### 5.4 测试覆盖率

- [ ] 每个需求对应至少一个单元测试
- [ ] 每个需求对应至少一个集成测试
- [ ] 所有测试通过

---

## 六、优先级建议

基于依赖关系和重要性，建议的实现顺序：

**第一阶段（P0 核心）：**
1. 需求 #1: @Builder 装饰器方法
2. 需求 #2: @Entry 装饰器验证与导出
3. 需求 #3: 资源引用处理

**第二阶段（P1 重要）：**
4. 需求 #10: 状态属性初始化
5. 需求 #4: 跳转语句
6. 需求 #7: for 循环完整支持
7. 需求 #8: async 方法转换

**第三阶段（P1 补充）：**
8. 需求 #5: JSDoc 注释保留
9. 需求 #6: 泛型语法处理
10. 需求 #9: 属性链式调用主体绑定

**第四阶段（P2 增强）：**
11. 需求 #11: 可选链和空值合并
12. 需求 #12: 解构赋值
13. 需求 #13: 生成器函数

---

## 七、代码质量问题（实际发现）

基于对 `src/test/resources/fixtures/harmony-utils/dist/` 产物的分析，发现以下需要修复的代码质量问题：

### 问题 #1: async 箭头函数转换丢失 async 关键字

**优先级：** P0 (Critical)

**描述：** 箭头函数的 `async` 修饰符在转换过程中丢失，导致 await 语法错误。

**实际案例：** `CryptographyPage.js` 第48-50行

**源代码（ETS）：**
```typescript
Button("生成密钥").onClick(async () => {
  this.keyText = await CryptographyUtil.generateAESKey();
})
```

**错误输出（JS）：**
```javascript
Button("生成密钥").onClick(() => {
    this.keyText = await CryptographyUtil.generateAESKey();
  });
```

**问题：** 箭头函数缺少 `async` 关键字，导致 `await` 在非 async 函数中使用，报错：`The 'await' operator can only be used in an 'async' function`

**预期输出（JS）：**
```javascript
Button("生成密钥").onClick(async () => {
    this.keyText = await CryptographyUtil.generateAESKey();
  });
```

**修复方案：**
1. 检查 `ArrowFunctionConverter` 是否正确处理 `async` 修饰符
2. 确保 `async` 关键字在箭头函数转换时被保留
3. 对于包含 `await` 表达式的箭头函数，自动添加 `async` 关键字

---

### 问题 #2: 代码缩进格式不正确

**优先级：** P0 (Critical)

**描述：** 生成的 JavaScript 代码缩进格式不正确，无法使用 IDE 格式化工具（Ctrl+Alt+L）进行格式化。

**实际案例：** `CryptographyPage.js` 第41-50行

**错误输出（JS）：**
```javascript
TextInput({placeholder: "输入文本"}).width("100%").height(50).onChange((value) => {
    this.inputText = value;
  });
Button("生成密钥").onClick(() => {
    this.keyText = await CryptographyUtil.generateAESKey();
  });
```

**问题：**
1. 函数体内容缩进在闭合括号 `}` 之后
2. 缩进层级不正确，导致 IDE 格式化工具无法识别正确的代码结构
3. 缺少统一的代码格式规范

**预期输出（JS）：**
```javascript
TextInput({placeholder: "输入文本"}).width("100%").height(50).onChange((value) => {
  this.inputText = value;
});
Button("生成密钥").onClick(async () => {
  this.keyText = await CryptographyUtil.generateAESKey();
});
```

**修复方案：**
1. 修复 `CodeGenerator` 中的缩进逻辑
2. 函数体内的语句应该相对于函数定义缩进一级
3. 确保闭合括号与函数定义对齐
4. 建立统一的代码格式规范（使用 2 空格或 4 空格统一缩进）

---

### 问题 #3: 输出产物未保持原始目录结构

**优先级：** P1

**描述：** 编译输出文件未按照源代码目录结构组织，所有 JS 文件都输出到 `dist/` 根目录。

**实际案例：**

**源代码目录结构：**
```
src/main/ets/
├── entryability/
│   ├── EntryAbility.ets
│   └── EntryBackupAbility.ets
├── pages/
│   ├── Index.ets
│   ├── ImagePage.ets
│   └── ...
├── services/
│   ├── CryptographyUtil.ets
│   ├── FileManager.ets
│   └── ...
└── utils/
    └── Logger.ets
```

**当前输出结构：**
```
dist/
├── EntryAbility.js           (扁平化)
├── Index.js                  (扁平化)
├── ImagePage.js              (扁平化)
├── CryptographyUtil.js       (扁平化)
├── Logger.js                 (扁平化)
└── ...
```

**预期输出结构：**
```
dist/main/ets/
├── entryability/
│   ├── EntryAbility.js
│   └── EntryBackupAbility.js
├── pages/
│   ├── Index.js
│   ├── ImagePage.js
│   └── ...
├── services/
│   ├── CryptographyUtil.js
│   ├── FileManager.js
│   └── ...
└── utils/
    └── Logger.js
```

**修复方案：**
1. 在 `EtsCompiler` 中添加路径映射逻辑
2. 保持源代码的目录结构
3. 支持配置输出目录（默认为 `dist/`，可配置为 `dist/main/ets/`）
4. 添加 `--preserve-dir-structure` 选项控制是否保持目录结构

---

### 问题 #4: const 变量声明缺少初始化器

**优先级：** P1

**描述：** 某些情况下生成的 `const` 变量声明缺少初始化器，导致语法错误。

**可能场景：**
- 解构赋值中的空模式
- 类型注解被移除后变量变为无初始化器

**示例问题代码：**
```javascript
const ;  // 错误：const 变量必须初始化
const { a, b, };  // 可能的问题
```

**修复方案：**
1. 检查 `VariableConverter` 的变量声明转换逻辑
2. 确保 `const` 声明都有初始化器
3. 对于没有初始化器的变量，改用 `let` 声明

---

### 问题 #5: 类字段声明格式不一致

**优先级：** P2

**描述：** 类字段在类体中使用赋值语法而非字段声明语法，虽然功能正确但格式不规范。

**实际案例：** `ImagePage.js` 第243-332行

**当前输出（JS）：**
```javascript
export class ImagePage extends View {
  selectedImageUri__ = "";
  processedImageUri__ = "";
  // ...
  get selectedImageUri() {
    return this.selectedImageUri__.get();
  }
}
```

**问题：** 字段使用赋值语法 `__ = ""` 而非字段声明语法 `__: string;`

**更好的格式（可选）：**
```javascript
export class ImagePage extends View {
  selectedImageUri__: ObservedPropertySimple<string> = new ObservedPropertySimple("", this);

  get selectedImageUri() {
    return this.selectedImageUri__.get();
  }
}
```

**注：** 当前格式功能正确，只是代码格式不够规范，优先级较低。

---

## 八、问题修复优先级

基于对产物质量的影响程度，建议的修复顺序：

**第一阶段（P0 - 必须立即修复）：**
1. **问题 #1**: async 箭头函数转换丢失 async 关键字
2. **问题 #2**: 代码缩进格式不正确

**第二阶段（P1 - 尽快修复）：**
3. **问题 #3**: 输出产物未保持原始目录结构
4. **问题 #4**: const 变量声明缺少初始化器

**第三阶段（P2 - 可选优化）：**
5. **问题 #5**: 类字段声明格式不一致
6. **需求 #5**: JSDoc 注释保留
7. **需求 #11-13**: 其他增强功能

---

## 附录：参考文档

1. **原始编译器实现**：`developtools_ace_ets2bundle`
2. **迭代2技术方案**：`docs/迭代2-技术实现方案-part1.md`
3. **迭代2技术方案**：`docs/迭代2-技术实现方案-part2.md`
4. **迭代3需求文档**：`docs/迭代3-需求说明书.md`
5. **迭代3技术方案**：`docs/迭代3-技术实现方案.md`
6. **迭代4需求文档**：`docs/迭代4需求说明书.md`
7. **迭代4技术方案**：`docs/迭代4-技术实现方案.md`

---

**文档版本：** v1.0
**编写日期：** 2026-01-31
**文档状态：** 基于迭代2-4缺失功能分析创建
